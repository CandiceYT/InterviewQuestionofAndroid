[TOC]



### 1.内存泄漏

#### (1) 何为内存泄漏

> 当一个对象已经不需要在使用了，本应该被回收，而另一个正在使用的对象持有它的引用，导致对象不能被回收。因为不能被及时回收的本该被回收的内存，就产生了内存泄漏。如果内存泄漏太多会导致程序没有办法申请内存，最后出现内存溢出的错误。

#### (2) 常见内存泄漏场景

> - 使用单例模式
> - 使用匿名内部类
> - 使用异步事件处理机制Handler
> - 使用静态变量
> - 资源未关闭
> - 设置监听
> - 使用AsyncTask
> - 使用Bitmap

#### (3) Java虚拟机内存管理

![](/Users/candice/Documents/笔记/Android/内存优化/Java虚拟机内存管理.png)

> ###### (1).虚拟机栈
>
> - 虚拟机栈主要的作用就是为执行java方法服务的，是Java方法执行的动态内存模型。
>
> ###### * 会导致栈内存溢出(StackOverFlowError)
>
> ###### (2).本地方法栈
>
> - 为执行native方法服务的，其他和虚拟机栈一样
>
> ###### (3).程序计数器
>
> - 是当前线程执行的字节码行号指示器
> - 处于线程独占区
> - 如果是执行的是java代码,当前值为字节码指令的地址，如果是Native，值为undefined
>
> ###### (4).堆
>
> - 存放对象的实例
> - 垃圾收集器管理的主要区域
> - 分代管理对象
> - 会导致内存溢出(OutOfMemoryError)
>
> ###### (5).方法区
>
>  - 存放虚拟机加载的类信息，常量，静态变量，编译后的代码和数据
>  - GC主要对方法区进行常量回收和类卸载
>  - 会出现内存溢出(OutOfMemoryError)
>

#### (4) Java内存几种分配策略

> ##### (1).静态的
>
> - 静态存储区：内存在程序编译期间就已经分配完成，一般来说，这个区域在程序运行期间一直处在
> - 它主要储存静态数据，全局静态数据和常量
>
> ##### (2).栈式的
>
> - 执行方法时，存储局部变量(编译期间，已经确定占用内存大小)，操作数，动态链接，方法出口
>
> ##### (3).堆式的
>
> - 也叫动态内存分配，主要存储对象实例，以及已经被加载类的Class对象(用于反射)

#### (5) 垃圾收集器是如何判断对象是否可回收

> *** 引用计数**(早期的主要用，native使用)
>
> 对象被引用，引用计数器加1，反之减一，只有引用计数为0,那么这个对象为垃圾对象
>
> *** 可达性**(现在大部分使用)
>
> 从GCRoot节点对象开始，看是否可以访问到此对象，如果没有访问到则为垃圾对象
>
> **可以作为GCRoot对象有以下几种：**
>
> - 虚拟机栈中的局部变量
> - 本地方法栈中的引用对象
> - 方法区中的常量引用对象
> - 方法区中的类属性引用对象

#### (6) 内存抖动

> 堆内存都有一定的大小，能容纳的数据是有限制的，当Java堆的大小太大时，垃圾收集会启动停止堆中不再应用的对象，来释放内存。当在极短时间内分配给对象和回收对象的过程就是内存抖动。

#### (7) 内存抖动产生的原因？

> 从术语上来讲就是极短时间内分配给对象和回收对象的过程。
>  一般多是在循环语句中创建临时对象，在绘制时配置大量对象或者执行动画时创建大量临时对象
>  内存抖动会带来UI的卡顿，因为大量的对象创建，会很快消耗剩余内存，导致GC回收，GC会占用大量的帧绘制时间，从而导致UI卡顿，关于UI卡顿会在后面章节讲到。

#### (8) Android中4种引用

> ###### (1).StrongReference强引用
>
> 从不被回收，java虚拟机停止时，才终止
>
> ###### (2).SoftReference软引用
>
> 当内存不足时，会主动回收，使用SoftReference使用结合ReferenceQueue构造有效期短
>
> ###### (3).WeakReference弱引用
>
> 每次垃圾回收时，被回收
>
> ###### (4).PhatomReference虚引用
>
> 每次垃圾回收时，被回收.结合ReferenceQueue来跟踪对象被垃圾回收器回收的活动

#### (9) 常见内存泄漏场景

> ##### (1).使用单例模式、**使用静态变量**

```java
  private static ComonUtil mInstance = null;
    private Context mContext = null;

    public ComonUtil(Context context) {
        mContext = context;
    }

    public static ComonUtil getInstance(Context context) {
        if (mInstance == null) {
            mInstance = new ComonUtil(context);
        }
        return mInstance;
    }
//使用
  ComonUtil mComonUtil = ComonUtil.getInstance(this);
```

> 我们看到上面的代码就是我们平时使用的单例模式，当然这里没有考虑线程安全，请忽略。当我们传递进来的是Context，那么当前对象就会持有第一次实例化的Context，如果Context是Activity对象，那么就会产生内存泄漏。因为当前对象ComonUtil是静态的，生命周期和应用是一样的，只有应用退出才会释放，导致Activity不能及时释放，带来内存泄漏。
>
> ###### 怎么解决呢？
>
> 常见的有两种方式，第一就是传入ApplicationContext，第二CommonUtil中取context.getApplicationContext()。

> ##### (2).使用非静态内部类

```java
/**
     * 非静态内部类
     */
    public void createNonStaticInnerClass(){
        CustomThread mCustomThread = new CustomThread();
        mCustomThread.start();
    }

    public class CustomThread extends Thread{
        @Override
        public void run() {
            super.run();
            while (true){
                try {
                    Thread.sleep(5000);
                    Log.i(TAG,"CustomThread ------- 打印");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

```

> 我们就以线程为例，当Activity调用了createNonStaticInnerClass方法，然后退出当前Activity时，因为线程还在后台执行且当前线程持有Activity引用，只有等到线程执行完毕，Activitiy才能得到释放，导致内存泄漏。
>  常用的解决方法有很多，第一把线程类声明为静态的类，如果要用到Activity对象，那么就作为参数传入且为WeakReference,第二在Activity的onDestroy时，停止线程的执行。

```java
  public static class CustomThread extends Thread{
        private WeakReference<MainActivity> mActivity;
        public CustomThread(MainActivity activity){
            mActivity = new WeakReference<MainActivity>(activity)
        }
    }
```

> ##### (3).**使用异步事件处理机制Handler**

```java
 /**
     * 异步消息处理机制  -- handler机制
     */
    public void createHandler(){
        mHandler.sendEmptyMessage(0);
    }
    public Handler mHandler = new Handler(new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            //处理耗时操作   
            return false;
        }
    });
```

> 这个应该是我们平时使用最多的一种方式，如果当handler中处理的是耗时操作，或者当前消息队列中消息很多时，那当Activity退出时，当前message中持有handler的引用，handler又持有Activity的引用，导致Activity不能及时的释放，引起内存泄漏的问题。
>  解决handler引起的内存泄漏问题常用的两种方式：
>  1.和上面解决Thread的方式一样，
>  2.在onDestroy中调用mHandler.removeCallbacksAndMessages(null)

```java
  @Override
    protected void onDestroy() {
        super.onDestroy();
        mHandler.removeCallbacksAndMessages(null);
    }
```

> ##### (4).资源未关闭
>
> - 数据库游标未关闭
> - 对象文件流未关闭
> - 注册/解注册未成对出现 

> ##### (5).设置监听
>
> 常见的是在观察者模式中出现，我们在退出Acviity时没有取消监听，导致被观察者还持有当前Activity的引用，从而引起内存泄漏。
> 常见的解决方法就是在onPause中注消监听

> ##### (6).**使用AsyncTask**

```java
public AsyncTask<Object, Object, Object> mTask = new AsyncTask<Object, Object, Object>() {

        @Override
        protected Object doInBackground(Object... params) {
            //耗时操作
            return null;
        }

        @Override
        protected void onPostExecute(Object o) {
        
        }   
    };
```

> 和上面同样的道理，匿名内部类持有外部类的引用，AsyncTask耗时操作导致Activity不能及时释放，引起内存泄漏。
> 解决方法同上:
> 1.声明为静态类，
> 2.在onPause中取消任务

> ##### (7).**使用Bitmap**
>
> 我们知道当bitmap对象没有被使用(引用)，gc会回收bitmap的占用内存，当时这边的内存指的是java层的，那么本地内存的释放呢？我们可以通过调用bitmap.recycle()来释放C层上的内存，防止本地内存泄漏

### 2.UI渲染优化

#### (1) ANR

>##### (1).什么是ANR?
>
>ANR全名Application Not Responding, 也就是"应用无响应".当操作在一段时间内系统无法处理时, 系统层面会弹出ANR对话框.
>
>##### (2).产生的原因
>
>APP的响应是Activity Manage和Window Manage来监控的，系统产生ANR的原因：
>
>- Activity5s内无法响应用户输入事件
>- BoradCastReceiver在10s内没有处理结束
>	上面两点的根本原因就是主线程有耗时操作。
>- Service在20s内没有处理
>
>##### (3).如何避免
>
>1. 耗时操作放到子线程操作
>2. I/O操作放到子线程
>3. 避免内存泄漏（内存不够也会造成ANR，当时大多数情况是OOM）
>
>##### (4).ANR如何分析？
>
>导出/data/anr/下的traces.txt,发现日志来定位问题
>
>```java
>adb pull data/anr/traces.txt ./
>```

#### (2) 怎么衡量渲染性能的好坏?

>##### (1).16ms
>
>要知道Android系统每隔16ms就发出VSYNC信号重新绘制一次Activity,所以要在16ms内能够完成绘制，这样才能达到每秒60帧，然而这个每秒帧数的参数由手机硬件所决定，现在大多数手机屏幕刷新率是60赫兹（赫兹是国际单位制中频率的单位，它是每秒中的周期性变动重复次数的计量），也就是说我们有16ms（1000ms/60次=16.66ms）的时间去完成每帧的绘制逻辑操作，就不会出现卡顿的现象，如果没有完成，则会丢帧导致卡顿。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image1.png)
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image2.png)

#### (3) 关于渲染管线

> Android系统的渲染管线分为两个关键组件：CPU和GPU，它们共同工作，在屏幕上绘制图片，每个组件都有自身定义的特定流程。我们必须遵守这些特定的操作规则才能达到效果。

![](/Users/candice/Documents/笔记/Android/内存优化/UI image3.png)

> CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。
>  在CPU方面，最常见的性能问题是不必要的布局和失效，这些内容必须在视图层次结构中进行测量、清除并重新创建，引发这种问题通常有两个原因：一是重建显示列表的次数太多，二是花费太多时间作废视图层次并进行不必要的重绘，这两个原因在更新显示列表或者其他缓存GPU资源时导致CPU工作过度。
>  在GPU方面，最常见的问题是我们所说的过度绘制（overdraw），通常是在像素着色过程中，通过其他工具进行后期着色时浪费了GPU处理时间。
>
> ##### (1).GPU
>
> ![](/Users/candice/Documents/笔记/Android/内存优化/UI image4.png)

> Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。

![](/Users/candice/Documents/笔记/Android/内存优化/UI image5.png)

> GPU使用一些指定的基础指令集，主要是多边形和纹理，也就是图片，CPU在屏幕上绘制图像前会向GPU输入这些指令，这一过程通常使用的API就是Android的OpenGL ES，这就是说，在屏幕上绘制UI对象时无论是按钮、路径或者复选框，都需要在CPU中首先转换为多边形或者纹理，然后再传递给GPU进行格栅化。
>  UI对象转换为一系列多边形和纹理的过程肯定相当耗时，从CPU上传处理数据到GPU同样也很耗时。所以很明显，我们需要尽量减少对象转换的次数，以及上传数据的次数，幸亏，OpenGL ES API允许数据上传到GPU后可以对数据进行保存，当我们下次绘制一个按钮时，只需要在GPU存储器里引用它，然后告诉OpenGL如何绘制就可以了，一条经验之谈：
>
> ###### 渲染性能的优化就是尽可能地上传数据到GPU，然后尽可能长地在不修改的情况下保存数据，因为每次上传资源到GPU时，我们都会浪费宝贵的处理时间.
>
> 为了能够使得App流畅，我们需要在每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作。

#### (4) 分析及解决方案

>##### (1). CPU
>
>上面已经分析过了，CPU常见的性能问题是不必要的布局和失效，引发这种问题通常有两个原因：一是重建显示列表的次数太多，二是花费太多时间作废视图层次并进行不必要的重绘。
>
>**布局失效优化**
>
>Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息,还有执行绘制操作的OpenGL命令列表。在某个View第一次需要被渲染时，Display List会因此被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。
>
>那么第二次渲染这个view会发生什么呢？
>
>**1.如果View的Property属性发生了改变（例如移动位置），我们就仅仅需要Execute Display List就够了.**

![](/Users/candice/Documents/笔记/Android/内存优化/UI image6.png)

> **2.如果你修改了View中的某些可见组件的内容，那么之前的DisplayList就无法继续使用了，我们需要重新创建一个DisplayList并重新执行渲染指令更新到屏幕上。任何时候View中的绘制内容发生变化时，都会需要重新创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。**

![](/Users/candice/Documents/笔记/Android/内存优化/UI image7.png)

> **3.如果某个View的大小需要增大到目前的两倍，在增大View大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。**

![](/Users/candice/Documents/笔记/Android/内存优化/UI image8.png)

> **嵌套结构优化**
>
> 提升布局性能的关键点是尽量保持布局层级的扁平化，避免出现重复的嵌套布局。
> 我们先来看下列子，然后再来总结：
> 当前页面有两个条目，上面条目是使用LinearLayout中嵌套LinearLayout实现的，下面条目使用一个RelativeLayout实现

https://www.jianshu.com/p/82f4fa395d9f

