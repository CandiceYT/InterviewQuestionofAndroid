[TOC]



### 1.内存泄漏

#### (1) 何为内存泄漏

> 当一个对象已经不需要在使用了，本应该被回收，而另一个正在使用的对象持有它的引用，导致对象不能被回收。因为不能被及时回收的本该被回收的内存，就产生了内存泄漏。如果内存泄漏太多会导致程序没有办法申请内存，最后出现内存溢出的错误。

#### (2) 常见内存泄漏场景

> - 使用单例模式
> - 使用匿名内部类
> - 使用异步事件处理机制Handler
> - 使用静态变量
> - 资源未关闭
> - 设置监听
> - 使用AsyncTask
> - 使用Bitmap

#### (3) Java虚拟机内存管理

![](/Users/candice/Documents/笔记/Android/内存优化/Java虚拟机内存管理.png)

> ###### (1).虚拟机栈
>
> - 虚拟机栈主要的作用就是为执行java方法服务的，是Java方法执行的动态内存模型。
>
> ###### * 会导致栈内存溢出(StackOverFlowError)
>
> ###### (2).本地方法栈
>
> - 为执行native方法服务的，其他和虚拟机栈一样
>
> ###### (3).程序计数器
>
> - 是当前线程执行的字节码行号指示器
> - 处于线程独占区
> - 如果是执行的是java代码,当前值为字节码指令的地址，如果是Native，值为undefined
>
> ###### (4).堆
>
> - 存放对象的实例
> - 垃圾收集器管理的主要区域
> - 分代管理对象
> - 会导致内存溢出(OutOfMemoryError)
>
> ###### (5).方法区
>
>  - 存放虚拟机加载的类信息，常量，静态变量，编译后的代码和数据
>  - GC主要对方法区进行常量回收和类卸载
>  - 会出现内存溢出(OutOfMemoryError)
>

#### (4) Java内存几种分配策略

> ##### (1).静态的
>
> - 静态存储区：内存在程序编译期间就已经分配完成，一般来说，这个区域在程序运行期间一直处在
> - 它主要储存静态数据，全局静态数据和常量
>
> ##### (2).栈式的
>
> - 执行方法时，存储局部变量(编译期间，已经确定占用内存大小)，操作数，动态链接，方法出口
>
> ##### (3).堆式的
>
> - 也叫动态内存分配，主要存储对象实例，以及已经被加载类的Class对象(用于反射)

#### (5) 垃圾收集器是如何判断对象是否可回收

> *** 引用计数**(早期的主要用，native使用)
>
> 对象被引用，引用计数器加1，反之减一，只有引用计数为0,那么这个对象为垃圾对象
>
> *** 可达性**(现在大部分使用)
>
> 从GCRoot节点对象开始，看是否可以访问到此对象，如果没有访问到则为垃圾对象
>
> **可以作为GCRoot对象有以下几种：**
>
> - 虚拟机栈中的局部变量
> - 本地方法栈中的引用对象
> - 方法区中的常量引用对象
> - 方法区中的类属性引用对象

#### (6) 内存抖动

> 堆内存都有一定的大小，能容纳的数据是有限制的，当Java堆的大小太大时，垃圾收集会启动停止堆中不再应用的对象，来释放内存。当在极短时间内分配给对象和回收对象的过程就是内存抖动。

#### (7) 内存抖动产生的原因？

> 从术语上来讲就是极短时间内分配给对象和回收对象的过程。
>  一般多是在循环语句中创建临时对象，在绘制时配置大量对象或者执行动画时创建大量临时对象
>  内存抖动会带来UI的卡顿，因为大量的对象创建，会很快消耗剩余内存，导致GC回收，GC会占用大量的帧绘制时间，从而导致UI卡顿，关于UI卡顿会在后面章节讲到。

#### (8) Android中4种引用

> ###### (1).StrongReference强引用
>
> 从不被回收，java虚拟机停止时，才终止
>
> ###### (2).SoftReference软引用
>
> 当内存不足时，会主动回收，使用SoftReference使用结合ReferenceQueue构造有效期短
>
> ###### (3).WeakReference弱引用
>
> 每次垃圾回收时，被回收
>
> ###### (4).PhatomReference虚引用
>
> 每次垃圾回收时，被回收.结合ReferenceQueue来跟踪对象被垃圾回收器回收的活动

#### (9) 常见内存泄漏场景

> ##### (1).使用单例模式、**使用静态变量**

```java
  private static ComonUtil mInstance = null;
    private Context mContext = null;

    public ComonUtil(Context context) {
        mContext = context;
    }

    public static ComonUtil getInstance(Context context) {
        if (mInstance == null) {
            mInstance = new ComonUtil(context);
        }
        return mInstance;
    }
//使用
  ComonUtil mComonUtil = ComonUtil.getInstance(this);
```

> 我们看到上面的代码就是我们平时使用的单例模式，当然这里没有考虑线程安全，请忽略。当我们传递进来的是Context，那么当前对象就会持有第一次实例化的Context，如果Context是Activity对象，那么就会产生内存泄漏。因为当前对象ComonUtil是静态的，生命周期和应用是一样的，只有应用退出才会释放，导致Activity不能及时释放，带来内存泄漏。
>
> ###### 怎么解决呢？
>
> 常见的有两种方式，第一就是传入ApplicationContext，第二CommonUtil中取context.getApplicationContext()。

> ##### (2).使用非静态内部类

```java
/**
     * 非静态内部类
     */
    public void createNonStaticInnerClass(){
        CustomThread mCustomThread = new CustomThread();
        mCustomThread.start();
    }

    public class CustomThread extends Thread{
        @Override
        public void run() {
            super.run();
            while (true){
                try {
                    Thread.sleep(5000);
                    Log.i(TAG,"CustomThread ------- 打印");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

```

> 我们就以线程为例，当Activity调用了createNonStaticInnerClass方法，然后退出当前Activity时，因为线程还在后台执行且当前线程持有Activity引用，只有等到线程执行完毕，Activitiy才能得到释放，导致内存泄漏。
>  常用的解决方法有很多，第一把线程类声明为静态的类，如果要用到Activity对象，那么就作为参数传入且为WeakReference,第二在Activity的onDestroy时，停止线程的执行。

```java
  public static class CustomThread extends Thread{
        private WeakReference<MainActivity> mActivity;
        public CustomThread(MainActivity activity){
            mActivity = new WeakReference<MainActivity>(activity)
        }
    }
```

> ##### (3).**使用异步事件处理机制Handler**

```java
 /**
     * 异步消息处理机制  -- handler机制
     */
    public void createHandler(){
        mHandler.sendEmptyMessage(0);
    }
    public Handler mHandler = new Handler(new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            //处理耗时操作   
            return false;
        }
    });
```

> 这个应该是我们平时使用最多的一种方式，如果当handler中处理的是耗时操作，或者当前消息队列中消息很多时，那当Activity退出时，当前message中持有handler的引用，handler又持有Activity的引用，导致Activity不能及时的释放，引起内存泄漏的问题。
>  解决handler引起的内存泄漏问题常用的两种方式：
>  1.和上面解决Thread的方式一样，
>  2.在onDestroy中调用mHandler.removeCallbacksAndMessages(null)

```java
  @Override
    protected void onDestroy() {
        super.onDestroy();
        mHandler.removeCallbacksAndMessages(null);
    }
```

> ##### (4).资源未关闭
>
> - 数据库游标未关闭
> - 对象文件流未关闭
> - 注册/解注册未成对出现 

> ##### (5).设置监听
>
> 常见的是在观察者模式中出现，我们在退出Acviity时没有取消监听，导致被观察者还持有当前Activity的引用，从而引起内存泄漏。
> 常见的解决方法就是在onPause中注消监听

> ##### (6).**使用AsyncTask**

```java
public AsyncTask<Object, Object, Object> mTask = new AsyncTask<Object, Object, Object>() {

        @Override
        protected Object doInBackground(Object... params) {
            //耗时操作
            return null;
        }

        @Override
        protected void onPostExecute(Object o) {
        
        }   
    };
```

> 和上面同样的道理，匿名内部类持有外部类的引用，AsyncTask耗时操作导致Activity不能及时释放，引起内存泄漏。
> 解决方法同上:
> 1.声明为静态类，
> 2.在onPause中取消任务

> ##### (7).**使用Bitmap**
>
> 我们知道当bitmap对象没有被使用(引用)，gc会回收bitmap的占用内存，当时这边的内存指的是java层的，那么本地内存的释放呢？我们可以通过调用bitmap.recycle()来释放C层上的内存，防止本地内存泄漏

分析工具：Android profiler

### 2.UI渲染优化

#### (1) ANR

>##### (1).什么是ANR?
>
>ANR全名Application Not Responding, 也就是"应用无响应".当操作在一段时间内系统无法处理时, 系统层面会弹出ANR对话框.
>
>##### (2).产生的原因
>
>APP的响应是Activity Manage和Window Manage来监控的，系统产生ANR的原因：
>
>- Activity5s内无法响应用户输入事件
>- BoradCastReceiver在10s内没有处理结束
>	上面两点的根本原因就是主线程有耗时操作。
>- Service在20s内没有处理
>
>##### (3).如何避免
>
>1. 耗时操作放到子线程操作
>2. I/O操作放到子线程
>3. 避免内存泄漏（内存不够也会造成ANR，当时大多数情况是OOM）
>
>##### (4).ANR如何分析？
>
>导出/data/anr/下的traces.txt,发现日志来定位问题
>
>```java
>adb pull data/anr/traces.txt ./
>```

#### (2) 怎么衡量渲染性能的好坏?

>##### (1).16ms
>
>要知道Android系统每隔16ms就发出VSYNC信号重新绘制一次Activity,所以要在16ms内能够完成绘制，这样才能达到每秒60帧，然而这个每秒帧数的参数由手机硬件所决定，现在大多数手机屏幕刷新率是60赫兹（赫兹是国际单位制中频率的单位，它是每秒中的周期性变动重复次数的计量），也就是说我们有16ms（1000ms/60次=16.66ms）的时间去完成每帧的绘制逻辑操作，就不会出现卡顿的现象，如果没有完成，则会丢帧导致卡顿。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image1.png)
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image2.png)

#### (3) 关于渲染管线

> Android系统的渲染管线分为两个关键组件：CPU和GPU，它们共同工作，在屏幕上绘制图片，每个组件都有自身定义的特定流程。我们必须遵守这些特定的操作规则才能达到效果。

![](/Users/candice/Documents/笔记/Android/内存优化/UI image3.png)

> CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。
>  在CPU方面，最常见的性能问题是不必要的布局和失效，这些内容必须在视图层次结构中进行测量、清除并重新创建，引发这种问题通常有两个原因：一是重建显示列表的次数太多，二是花费太多时间作废视图层次并进行不必要的重绘，这两个原因在更新显示列表或者其他缓存GPU资源时导致CPU工作过度。
>  在GPU方面，最常见的问题是我们所说的过度绘制（overdraw），通常是在像素着色过程中，通过其他工具进行后期着色时浪费了GPU处理时间。
>
> ##### (1).GPU
>
> ![](/Users/candice/Documents/笔记/Android/内存优化/UI image4.png)

> Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。

![](/Users/candice/Documents/笔记/Android/内存优化/UI image5.png)

> GPU使用一些指定的基础指令集，主要是多边形和纹理，也就是图片，CPU在屏幕上绘制图像前会向GPU输入这些指令，这一过程通常使用的API就是Android的OpenGL ES，这就是说，在屏幕上绘制UI对象时无论是按钮、路径或者复选框，都需要在CPU中首先转换为多边形或者纹理，然后再传递给GPU进行格栅化。
>  UI对象转换为一系列多边形和纹理的过程肯定相当耗时，从CPU上传处理数据到GPU同样也很耗时。所以很明显，我们需要尽量减少对象转换的次数，以及上传数据的次数，幸亏，OpenGL ES API允许数据上传到GPU后可以对数据进行保存，当我们下次绘制一个按钮时，只需要在GPU存储器里引用它，然后告诉OpenGL如何绘制就可以了，一条经验之谈：
>
> ###### 渲染性能的优化就是尽可能地上传数据到GPU，然后尽可能长地在不修改的情况下保存数据，因为每次上传资源到GPU时，我们都会浪费宝贵的处理时间.
>
> 为了能够使得App流畅，我们需要在每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作。

#### (4) 分析及解决方案

>##### (1). CPU
>
>上面已经分析过了，CPU常见的性能问题是不必要的布局和失效，引发这种问题通常有两个原因：一是重建显示列表的次数太多，二是花费太多时间作废视图层次并进行不必要的重绘。
>
>**布局失效优化**
>
>Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息,还有执行绘制操作的OpenGL命令列表。在某个View第一次需要被渲染时，Display List会因此被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。
>
>那么第二次渲染这个view会发生什么呢？
>
>**1.如果View的Property属性发生了改变（例如移动位置），我们就仅仅需要Execute Display List就够了.**

![](/Users/candice/Documents/笔记/Android/内存优化/UI image6.png)

> **2.如果你修改了View中的某些可见组件的内容，那么之前的DisplayList就无法继续使用了，我们需要重新创建一个DisplayList并重新执行渲染指令更新到屏幕上。任何时候View中的绘制内容发生变化时，都会需要重新创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。**

![](/Users/candice/Documents/笔记/Android/内存优化/UI image7.png)

> **3.如果某个View的大小需要增大到目前的两倍，在增大View大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。**

![](/Users/candice/Documents/笔记/Android/内存优化/UI image8.png)

> **嵌套结构优化**
>
> 提升布局性能的关键点是尽量保持布局层级的扁平化，避免出现重复的嵌套布局。
> 我们先来看下列子，然后再来总结：
> 当前页面有两个条目，上面条目是使用LinearLayout中嵌套LinearLayout实现的，下面条目使用一个RelativeLayout实现

![](/Users/candice/Documents/笔记/Android/内存优化/UI image9.png)

> ##### (2). 优化建议
>
> - ###### 没有用的父布局时指没有背景绘制或者没有大小限制的父布局，这样的布局不会对UI效果产生任何影响。我们可以把没有用的父布局，通过<merge/>标签合并来减少UI的层次
>
> - ###### 使用线性布局LinearLayout排版导致UI层次变深，如果有这类问题，我们就使用相对布局RelativeLayout代替LinearLayout,减少UI的层次
>
> - ###### 不常用的UI被设置成GONE,比如异常的错误页面，如果有这类问题，我们需要用<ViewStub/>标签，代替GONE提高UI性能
>
> ##### (3).常用优化示例
>
> - ######  include 标签
>
> 	include标签常用于将布局中的公共部分提取出来供其他layout共用，以实现布局模块化，这在布局编写方便提供了大大的便利。
>
> - ###### viewstub 标签
>
> 	viewstub标签同include标签一样可以用来引入一个外部布局，不同的是，viewstub引入的布局默认不会扩张，即既不会占用显示也不会占用位置，从而在解析layout时节省cpu和内存。
> 	 viewstub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等。
>
> 	ViewStub所加载的布局是不可以使用<merge>标签的
>
> ```java
>    //第一种
>     ViewStub stub = (ViewStub)findViewById(...)
>     View stubView=  stub.inflate();
>     //根据实际情况，显示
>     stubView.setVisibility()
> 
>     //第二种
>     View viewStub = findViewById(R.id.network_error_layout);
>     viewStub.setVisibility(View.VISIBLE);   // ViewStub被展开后的布局所替换
> ```
>
> -  **merge 标签**
>
> 在使用了include后可能导致布局嵌套过多，多余不必要的layout节点，从而导致解析变慢
>
> ###### merge标签可用于两种典型情况：
>
> (1). 布局顶结点是FrameLayout且不需要设置background或padding等属性，可以用merge代替，因为Activity内容试图的parent view就是个FrameLayout，所以可以用merge消除只剩一个。
>  (2). 某布局作为子布局被其他布局include时，使用merge当作该布局的顶节点，这样在被引入时顶结点会自动被忽略，而将其子节点全部合并到主布局中。

>##### (3).GPU
>
>在GPU方面，最常见的问题是我们所说的过度绘制（overdraw），通常是在像素着色过程中，通过其他工具进行后期着色时浪费了GPU处理时间。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image10.png)
>
>

> 过度绘制描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区域被绘制了多次。这样就会浪费大量的CPU以及GPU资源。
>  当设计上追求更华丽的视觉效果的时候，我们就容易陷入采用复杂的多层次重叠视图来实现这种视觉效果的怪圈。这很容易导致大量的性能问题，为了获得最佳的性能，我们必须尽量减少Overdraw的情况发生。
>
> 幸运的是，我们可以通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，观察UI上的Overdraw情况。
>
> ![](/Users/candice/Documents/笔记/Android/内存优化/UI image11.png)

>###### GPU Profiling
>
>从Android M系统开始，系统更新了GPU Profiling的工具来帮助我们定位UI的渲染性能问题。早期的CPU Profiling工具只能粗略的显示出Process，Execute，Update三大步骤的时间耗费情况。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image12.png)
>
>但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在Android M版本开始，GPU Profiling工具把渲染操作拆解成如下8个详细的步骤进行显示。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image14.png)

>旧版本中提到的Proces，Execute，Update还是继续得到了保留，他们的对应关系如下：
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image15.png)

>- Sync & Upload：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。
>- Measure & Layout：这里表示的是布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。
>- Animation：表示的是计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。
>- Input Handling：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。
>- Misc/Vsync Delay：如果稍加注意，我们可以在开发应用的Log日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况。
>
>上面八种不同的颜色区分了不同的操作所耗费的时间，为了便于我们迅速找出那些有问题的步骤，GPU Profiling工具会显示16ms的阈值线，这样就很容易找出那些不合理的性能问题，再仔细看对应具体哪个步骤相对来说耗费时间比例更大，结合上面介绍的细化步骤，从而快速定位问题，修复问题。
>
>##### (4).优化建议
>
>- **移除Window默认的Background**
>
>- ###### 移除XML布局文件中非必需的Background
>
>- **按需显示占位背景图片**
>
>	在给ImageView设置图片时，判断是否获取到对应的Bitmap，在获取到图像之后，把ImageView的Background设置为Transparent，只有当图像没有获取到的时候才设置对应的Background占位图片，这样可以避免因为设置背景图而导致的过度渲染。
>
>- **剪辑不显示的UI组件**
>
>	对不可见的UI组件进行绘制更新会导致Overdraw。例如Nav Drawer从前置可见的Activity滑出之后，如果还继续绘制那些在Nav Drawer里面不可见的UI组件，这就导致了Overdraw。为了解决这个问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少Overdraw。那些Nav Drawer里面不可见的View就不会被执行浪费资源。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image16.png)
>
>但是不幸的是，对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。
> 除了clipRect方法之外，我们还可以使用canvas.quickreject()来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。
> 下面我们来看个实例：
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image17.png)

>```java
>@Override
>protected void onDraw(Canvas canvas) {
>      super.onDraw(canvas);
>      if (mCardList != null && mCardList.size() > 0) {
>           for (int i = 0; i < mCardList.size(); i++) {
>              mCardLeft = i * mCardSpacing;
>              drawCard(canvas, mCardList.get(i), mCardLeft, 0);
>          }
>      }
>}
>
>private void drawCard(Canvas canvas, CardItem card, int left, int top) {
>        Bitmap mBitmap = getBitmap(card.resId);
>        canvas.drawBitmap(mBitmap, left, top, mPaint);
>    }
>
>private Bitmap getBitmap(int resId) {
>  return BitmapFactory.decodeResource(this.getResources(), resId);
>}
>```
>
>我们看到扑克牌有不可见的区域但是还是被绘制了，导致过度绘制。下面我们进行剪辑。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image18.png)
>
>```java
>    @Override
>    protected void onDraw(Canvas canvas) {
>        super.onDraw(canvas);
>        if (mCardList != null && mCardList.size() > 0) {
>            for (int i = 0; i < mCardList.size()-1; i++) {
>                mCardLeft = i * mCardSpacing;
>                canvas.save();
>                canvas.clipRect(mCardLeft,
>                        0f,
>                        mCardLeft + mCardSpacing,
>                        mCardList.get(i).getHeight());
>                drawCard(canvas, mCardList.get(i), mCardLeft, 0);
>                canvas.restore();
>            }
>            drawCard(canvas, mCardList.get(mCardList.size()-1), mCardLeft + mCardSpacing, 0);
>        }
>    }
>```
>
>**有些过度绘制对于运行性能，可能是必要的也是可以接受的，比如说Android的ActionBar，但是，如果我们希望应用体验更进一步，我们可以考虑尽可能地减少过度绘制。**
>
>##### (5).其他问题引起的卡粉分析
>
>**内存抖动**
>
>内存抖动是因为在短时间内大量的对象被创建又马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，会触发GC从而导致刚产生的对象又很快被回收。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题(卡顿)。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image19.png)

> 解决上面的问题有简洁直观方法，如果你在Memory Monitor里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。
>
> ![](/Users/candice/Documents/笔记/Android/内存优化/UI image20.png)

> 同时我们还可以通过Allocation Tracker来查看在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一。
>
> 当你大致定位问题之后，接下去的问题修复也就显得相对直接简单了。例如，你需要避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外，自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。
>
> 工具 DDMS  Allocation Tracker  layoutinspector  **Traceview**   **Systrace**

### 3.计算性能优化

​	Android中的Java代码会需要经过编译优化再执行的过程。代码的不同写法会影响到Java编译器的优化效率。例如for循环的不同写法就会对编译器优化这段代码产生不同的效率，当程序中包含大量这种可优化的代码的时候，运算性能就会出现问题。想要知道如何优化代码的运算性能就需要知道代码在硬件层的执行差异。

#### (1) 低效率函数

> 如果你写了一段代码，它的执行效率比想象中的要差很多。我们需要知道有哪些因素有可能影响到这段代码的执行效率。例如：比较两个float数值大小的执行时间是int数值的4倍左右。这是因为CPU的运算架构导致的，如下图所示：

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image1.png)

> 虽然现代的CPU架构得到了很大的提升，也许并不存在上面所示的那么大的差异，但是这个例子说明了代码写法上的差异会对运算性能产生很大的影响。
>
> 通常来说有两类运行效率差的情况：第1种是相对执行时间长的方法，我们可以很轻松的找到这些方法并做一定的优化。第2种是执行时间短，但是执行频次很高的方法，因为执行次数多，累积效应下就会对性能产生很大的影响。
>
> 修复这些细节效率问题，需要使用Android SDK提供的工具，进行仔细的测量，然后再进行微调修复。
>
> 工具  android profiler 的**Traceview**

#### (2)优化

>##### (1).批量处理与缓存
>
>为了提升运算性能，这里介绍2个非常重要的技术:批处理与缓存
> 是在真正执行运算操作之前对数据进行批量预处理，例如你需要有这样一个方法，它的作用是查找某个值是否存在与于一堆数据中。假设一个前提，我们会先对数据做排序，然后使用二分查找法来判断值是否存在。我们先看第一种情况，下图中存在着多次重复的排序操作。

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image2.png)

>在上面的那种写法下，如果数据的量级并不大的话，应该还可以接受，可是如果数据集非常大，就会有严重的效率问题。那么我们看下改进的写法，把排序的操作打包绑定只执行一次

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image3.png)

>上面就是批处理的一种示例：把重复的操作拎出来，打包只执行一次。
> 缓存相对比较简单，就是把经常处理的数据先缓存起来，使用时直接获取，但是要注意，当代码执行完毕需要回收（当然也可以使用weakRefrence）。
>
>###### (2).主线程阻塞
>
>为了确保应用程序的高性能，每项功能都应该尽可能高效地运行。但是这些功能的执行时间以及它们在代码中所处的位置也很重要，当你首次启动一个Android应用程序时，朱执行线程就已经创建了，主线程非常重要，因为它负责运行你的代码，并在合适的视图位置发送事件和执行绘图功能。这些前面我们已经讲过，基本上来说，主线程是应用程序所在的线程，有时候，主线程也称为UI线程。例如，如果你触摸屏幕上的按钮，UI线程将会发送一个触摸事件给视图，视图将按钮状态设定为已按下设定，然后向事件队列发送一个有效请求，然后UI线程处理此请求，并通知按钮将其本身绘制为已按下状态。如果你有任何触摸事件的处理代码块，将会在线程中执行，这些触摸处理所用的时间越长，线程的执行时间就会越长，在绘图功能执行完之前，视图将会更新显示状态，让用户能够看到其状态，这里需要记住的是，输入处理代码与渲染和更新代码，共享这个线程的处理周期时间。

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image4.png)

>这意味着，在触摸事件处理，网络访问或数据库查询等计算周期时间，UI不会更新绘图，在简单的情况下，渲染周期可能会延误16毫秒左右，而让用户感到延迟。但是，如果你暂停UI线程渲染超过5秒，用户将会看到“应用程序未响应”对话框，并询问用户是否会想要关闭你的应用程序，这样可能导致用户停止使用。那你如何解决这个问题，你要找出不需要在主线程上执行的功能，也就是说，不需要等它们完成之后，才能执行绘图。你应该将这个功能转移到一个单独的独立线程，这个线程不会阻止UI线程。例如，如果你按一下提交按钮，以完成一个订单，然后编写和发送确认邮件，

![](这可以在单独的线程上完成。Android有系列很好用的API，能够简化这些工作。

> ###### (3).异步任务
>
> 给耗时操作建立异步任务，比如网络请求，图片处理等等，任务完成通知主线程。
>
> ###### (4).容器性能
>
> 前面我们讲过，一些类型的硬件可能会造成程序执行速度较慢，还记得那个浮点分支问题吗？对于今天的硬件来说，这已经不是问题。但是有一些问题还是需要引起注意，比如说，你所使用的编程语言的基本元素的效率，以排序等基本算法为例，现在，有很多的排序算法，对于不同的情况，它们各有优劣，例如，当元素数量少于一千或在大型已排序列表中寻找一个对象时，快速排序法通常比起冒泡排序法更快。一般情况下，最好的方法是二分查找算法，但是，当在未排数组中寻找对象时情况变得完全不同，不同于比较每一个对象以查找你想要的值。你可以使用一个哈希函数来立即找到它，这是现代计算机科学和数据结构方面的基本知识。

> 幸运的是，现代编程语言像Java等，为你提供了这些容器和算法，因此你不再需要自己反复地编写Murmur3哈希函数和快速排序算法。但是你需要知道另外一些事情，在我多年的编程生涯中，一个经常会影响项目性能的问题，是由于这些语言提供的容器对象的性能所引起的。这听起来不可思议！Java提供一个矢量类的实现，你可以任意push、pop，添加和取消对象，为了获得这种灵活性，它在内部使用链式列表结构，这种结构具有一系列独特的性能特性，在你操作这种列表时，它的速度超级快，但是，当你在其他位置进行插入或删除时，它会消耗大量的时间。我要说的是，底层系统提供的这些容器并不会考虑，你的程序将会如何实际使用它们，James Sutherland发表了一系列的基准测试报告，他认为，我们需要注意性能与功能之间的一些差异。例如，他发现Hashtable比HashMap大约快22%，具体视你如何使用这些容器而有所不同，我们需要思考的是，你是否曾经分析过你在代码中使用的容器类。你是否坚信，你在代码中使用的容器的实际运行速度绝对是最快的。一个好消息是，你可以使用Android中的MPI来剖析这些容器的性能。

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image6.png)

>###### (5).数据结构
>
>创建应用时，容器中不恰当的数据结构所造成的性能问题，为此我们可以使用Android SDK中的工具，来识别不恰当数据结构带来的性能问题。

### 4.电量优化

​	当我们使用Android完成任务时，设备硬件正在快速消耗电池电量来完成这些任务。任务越繁重，消耗的电量越多越快。这样用户就会在想是哪一个应用导致电量消耗的怎么快的？要想写出耗电量低的应用的关键是要透彻理解电量消耗的全部过程。 我们很想知道我的应用执行的哪些任务消耗的电量是最多的？这个问题确实会很棘手。电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗（因为第三方硬件监测的时候是用的自己的供电而不是用的手机的电量）。

#### (1)电量消耗分析

>待机状态的电量分析
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image1.png)

>使用和唤醒屏幕后
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image2.png)

>当设备从休眠状态中，被应用程序假面唤醒时，你会看到在第一次唤醒时，这里有一条电量使用高峰线
>
>CUP唤醒时的高峰线
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image3.png)

>后续的一些执行的消耗
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image4.png)

>值得注意的是当工作完成后，设备会主动进行休眠，这非常重要，在不使用或者很少使用的情况下，长时间保持屏幕唤醒会迅速消耗电池的电量。
>
>**蜂窝式无线**
> 当设备通过无线网发送数据的时候，为了使用硬件，这里会出现一个唤醒好点高峰。接下来还有一个高数值，这是发送数据包消耗的电量，然后接受数据包也会消耗大量电量 也看到一个峰值。
> 所以我们知道了，开启无线模式这个过程非常耗电，那么硬件这块为了防止频繁开启关闭耗电，采取了一个无奈的办法，会在一个小段时间内保持开启模式，防止短时间内还有数据包需要接收。这些数据非常有用，可是 不是所有开发者都有这个第三方设备跟踪。但是使用Android L版本就可以利用到新的一系列的工具来优化应用程序的耗电。（这里显然不要考虑兼容性问题吧，我只是想测电量消耗问题，同一款APP在不同版本上耗电情况应该不会有太大影响。）

#### (2) Battery Historian(电量使用记录分析工具)

>Battery Historian是Android 5.0开始引入的新API。通过下面的指令，可以得到设备上的电量消耗信息:
>
>###### 2.1 配置分析环境
>
>第一种 通过安装Docker环境来安装
> 因本人没有使用这种，想要了解的朋友可以参考文档
> 第二种 源码安装
>
>###### (1).GO环境安装[下载](https://golang.org/doc/install?download=go1.7.3.windows-amd64.msi) 
>
>###### (2). 安装Git[下载](https://git-scm.com/) 
>
>###### (3). 安装Python[下载](https://www.python.org/) 
>
>###### (4). 安装Java环境
>
>###### (5). 下载Battery Historian源码并且运行
>
>**下载源码**
>
>```
> go get -d -u github.com/google/battery-historian/
>```
>
>**运行Battery Historian**
>
>```
>cd $GOPATH/src/github.com/google/battery-historian
>    go run setup.go
>```

>**开启服务**
>
>```
>   go run cmd/battery-historian/battery-historian.go
>```
>
>**检查/battery-historian是否运行**
>
>```
>检查/battery-historian是否运行
>```
>
>###### 2.2 导出电量发现文件
>
>historian-V1
>
>```
>$ adb shell dumpsys batterystats > xxx.txt  //得到整个设备的电量消耗信息
>    $ adb shell dumpsys batterystats > com.package.name > xxx.txt //得到指定app相关的电量消耗信息
>```
>
>historian-V2
>android 6.0 以及以下版本
>
>```
>  adb bugreport > bugreport.txt
>```
>
>android 7.0
>
>```
>adb bugreport bugreport.zip
>```
>
>###### 2.3 开始分析
>
>启动battery-historian服务，打开[http://localhost:9999](http://localhost:9999/)，上传bugreport.txt或者bugreport.zip文件
>
>待补充

https://www.jianshu.com/p/6affacabad5b

#### (3) 如何保持设备唤醒状态

>当Android设备空闲时,屏幕会变暗，然后关闭屏幕，最后会停止CPU的运行，这样可以防止电池电量掉的快。在休眠过程中自定义的Timer、Handler、Thread、Service等都会暂停。
>
>###### 什么情况下需要唤醒设备？
>
>对于一些带通讯功能的应用，通讯的心跳包会在熄屏不久后停止网络访问，所以需要定时唤醒cpu。
> 后台关键逻辑代码执行时，防止cpu休眠
> 后台长连接的状态
> 后台定时任务执行
>
>常用唤醒设备的方法
>
>##### (1).保持屏幕常亮
>
>- activity中设置
>
>```java
>//保持屏幕常亮
> getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
> //取消屏幕常亮
> getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
>```
>
>- 配置文件中设置
>
>```java
><RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
>        xmlns:tools="http://schemas.android.com/tools"
>        android:id="@+id/activity_screen_on"
>        android:layout_width="match_parent"
>        android:layout_height="match_parent"
>        android:keepScreenOn="true">
>```
>
>这个方法的好处是不像唤醒锁（wake locks），需要一些特定的权限（permission）。并且能正确管理不同app之间的切换，不用担心无用资源的释放问题。
>
>##### (2).保持CPU运行(wake locks)
>
>wake_lock锁主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。
> 需要使用PowerManager这个系统服务的唤醒锁(wake locks)特征来保持CPU处于唤醒状态。唤醒锁允许程序控制宿主设备的电量状态。创建和持有唤醒锁对电池的续航有较大的影响，所以，除非是真的需要唤醒锁完成尽可能短的时间在后台完成的任务时才使用它。
>
>###### 使用场景
>
>在使用后台服务在屏幕关闭情况下hold住CPU完成一些工作。
>
>###### 不使用wake locks,执行长时间任务可能导致的问题？
>
>如果不使用唤醒锁来执行后台服务，不能保证因CPU休眠未来的某个时刻任务会停止
>
>###### 唤醒锁可划分为并识别四种用户唤醒锁：
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image5.png)

>**注意： android sdk 大于17 后，FULL_WAKE_LOCK 将被弃用。 应用应使用 FLAG_KEEP_SCREEN_ON。**
>
>###### wake locks 使用步骤
>
>- ###### 添加唤醒锁权限
>
>```java
><uses-permission android:name="android.permission.WAKE_LOCK" />
>```
>
>- 使用
>
>```java
>PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);
>PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "myPartialWakeLock");
>//唤醒
>wakeLock.acquire();
>//执行任务
>doJob();
>//释放锁
>if (wakeLock.isHeld()) {
>   wakeLock.release();
>}
>```
>

>**注意：在使用该类的时候，必须保证acquire和release是成对出现的。**
>
>我们也可以使用带超时的acquire,防止没有手动释放
>
>**WakefulBroadcastReceiver**
>
>官方推荐使用WakefulBroadcastReceiver。下面来看下定义和使用。
> WakefulBroadcastReceiver是BroadcastReceiver的一种特例。它会为你的APP创建和管理一个PARTIAL_WAKE_LOCK 类型的WakeLock。WakefulBroadcastReceiver把工作交接给service（通常是IntentService），并保证交接过程中设备不会进入休眠状态。如果不持有WakeLock，设备很容易在任务未执行完前休眠。最终结果是你的应用不知道会在什么时候能把工作完成，相信这不是你想要的。
>
>**使用**
>
>- 注册
>
>- ```java
>	 <receiver android:name=".battery.MyWakefulReceiver"></receiver>
>	```
>
>- 使用
>
>- ```java
>	public class MyWakefulReceiver extends WakefulBroadcastReceiver {       
>	        @Override
>	        public void onReceive(Context context, Intent intent) {
>	            Intent mIntent = new Intent(context,MyService.class);
>	            startWakefulService(context,mIntent);
>	        }
>	    }
>	    public class MyService extends IntentService {
>	        /**
>	         * Creates an IntentService.  Invoked by your subclass's constructor.
>	         *
>	         * @param name Used to name the worker thread, important only for debugging.
>	         */
>	        public MyService(String name) {
>	            super(name);
>	        }
>	
>	        @Override
>	        protected void onHandleIntent(Intent intent) {
>	            Bundle extras = intent.getExtras();
>	            //执行任务
>	            doJob();        
>	            MyWakefulReceiver.completeWakefulIntent(intent);
>	        }
>	```
>
>**AlarmManager 唤醒CPU**
>
>###### **为什么AM能在cpu休眠时，唤醒它呢？**
>
>首先Android手机有两个处理器，一个叫Application Processor（AP），一个叫Baseband Processor（BP）。AP是ARM架构的处理器，用于运行Linux+Android系统；BP用于运行实时操作系统（RTOS），通讯协议栈运行于BP的RTOS之上。非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高。另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。一般手机待机时，AP、LCD、WIFI均进入休眠状态，这时Android中应用程序的代码也会停止执行。
>
>Android为了确保应用程序中关键代码的正确执行，提供了Wake Lock的API，使得应用程序有权限通过代码阻止AP进入休眠状态。但如果不领会Android设计者的意图而滥用Wake Lock API，为了自身程序在后台的正常工作而长时间阻止AP进入休眠状态，就会成为待机电池杀手。
>
>AlarmManager 是Android 系统封装的用于管理 RTC 的模块，RTC (Real Time Clock) 是一个独立的硬件时钟，可以在 CPU 休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。
>
>**使用：**
>
>```java
>    public void btn_alarm(View view){
>        Intent mIntent = new Intent(view.getContext(),TestService.class);
>        PendingIntent pendingIntent = PendingIntent.getService(view.getContext(),mRequestCode,mIntent,mFlags);
>        AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);
>        if(alarmManager != null){
>            long mTriggerTime = System.currentTimeMillis() + 1000;
>            long mItervalTime = 2000;
>            alarmManager.cancel(pendingIntent);
>            //闹钟在系统睡眠状态下会唤醒系统并执行提示功能
>            alarmManager.setRepeating(AlarmManager.RTC_WAKEUP,mTriggerTime,mItervalTime,pendingIntent);
>//            alarmManager.setExact(AlarmManager.RTC_WAKEUP,mTriggerTime,pendingIntent);
>//            alarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pendingIntent);
>        }
>    }
>```
>
>该定时器可以启动Service服务、发送广播、跳转Activity，并且会在系统睡眠状态下唤醒系统。所以该方法不用获取电源锁和释放电源锁。
>
>**注意：在19以上版本，setRepeating中设置的频繁只是建议值(6.0 的源码中最小值是60s)，如果要精确一些的用setWindow或者setExact。**
>
>**注意：由于手机厂商做了心跳对齐，所有的app后台唤醒频率不能太高，不然会无效。**
>
>**总结:**
>
>- 关键逻辑的执行过程，就需要Wake Lock来保护。如断线重连重新登陆
>
>- 2.休眠的情况下如何唤醒来执行任务？用AlarmManager。如推送消息的获取
>
>###### 注意：如果请求网络很差，会要很长的时间，一般我们谷歌建议一定要设置请求超时时间。

#### (4) 电量优化建议

>##### 4.1**充电时执行任务**
>
>为了省电，有些工作可以放当手机插上电源的时候去做。往往这样的情况非常多。像这些不需要及时地和用户交互的操作可以放到后面处理。
>
>```java
>if (!checkForPower()) {
>        Toast.makeText(view.getContext(), "当前非充电状态", Toast.LENGTH_SHORT).show();
>        return;
>    }
>    /**
>         * 是否充电
>         * AC --- 交流电
>         * USB
>         * WireLess -- 无线充电
>         *
>         * @return
>         */
>        private boolean checkForPower() {
>            IntentFilter mIntentFilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
>            Intent intent = registerReceiver(null, mIntentFilter);
>            int plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
>
>            boolean isUsb = plugged == BatteryManager.BATTERY_PLUGGED_USB;
>            boolean isAc = plugged == BatteryManager.BATTERY_PLUGGED_AC;
>            boolean isWireless = false;
>            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
>                //api >= 17
>                isWireless = plugged == BatteryManager.BATTERY_PLUGGED_WIRELESS;
>            }
>            return (isUsb || isAc || isWireless);
>        }
>
>
>```
>
>##### 4.2 **连接Wifi后执行任务**
>
>我们知道wifi网络传输的电量消耗要比移动网络少很多，应该尽量减少移动网络下的数据传输，多在WiFi环境下传输数据，所以我们可以把一些不需要实时性的任务留到连接wifi后在执行
>
>##### 4.3 **wake_lock**
>
>系统为了节省电量，CPU在没有任务忙的时候就会自动进入休眠。
> 有任务需要唤醒CPU高效执行的时候，就会给CPU加wake_lock锁。
> 但是根据我们上面的讲解，使用wake_lock结束时需要释放锁，如果忘记释放，会使得CPU一直执行消耗电量，所以推荐使用带超时的wake lock或者WakefulBroadcastReceiver
>
>```java
>   wakeLock.acquire(timeout);
>```

>##### 4.4 **大量高频次的CPU唤醒及操作集中处理**
>
>我们希望把频繁的间隔任务集中起来进行批量执行， 这正是JobScheduler API所做的事情。它会根据当前的情况与任务，组合出理想的唤醒时间，例如等到正在充电或者连接到WiFi的时候，或者集中任务一起执行。我们可以通过这个API实现很多免费的调度算法。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image6.png)

>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image7.png)
>
>###### JobScheduler
>
>使用Job Scheduler，应用需要做的事情就是判断哪些任务是不紧急的，可以交给Job Scheduler来处理，Job Scheduler集中处理收到的任务，选择合适的时间，合适的网络，再一起进行执行。使用(android api >= 21)
>
>```java
>@TargetApi(Build.VERSION_CODES.LOLLIPOP)
>    public class JobWakeUpService extends JobService{
>        private int mJobID = 100;
>        private JobScheduler mJobScheduler;
>        private long mIntervalMillis = 6000;
>        private long mMinLatencyMillis = 5000;
>        private long mMaxExecutionDelayMillis = 10000;
>
>        @Override
>        public int onStartCommand(Intent intent, int flags, int startId) {
>            JobInfo mJobInfo = new JobInfo.Builder(mJobID,new ComponentName(this,JobWakeUpService.class))
>                    .setPeriodic(mIntervalMillis)//设备重启，任务是否保留
>                    .setMinimumLatency(mMinLatencyMillis)//最小延时
>                    .setOverrideDeadline    (mMaxExecutionDelayMillis)//最大执行时间
>                    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)//网络类型 NETWORK_TYPE_UNMETERED（wifi 蓝牙）
>                    .setRequiresCharging(true) //充电时执行
>                    //设置重试/退避策略 （重试时间，重试时间间隔）
>                    .setBackoffCriteria(mInitialBackoffMillis,JobInfo.BACKOFF_POLICY_LINEAR)
>                    .build();
>
>            mJobScheduler = (JobScheduler) getSystemService(JOB_SCHEDULER_SERVICE);
>            mJobScheduler.schedule(mJobInfo);
>            return START_STICKY;
>        }
>
>        @Override
>        public boolean onStartJob(JobParameters params) {
>            if(!isServiceWork(this,TestService.class.getName())){
>                startService(new Intent(this,TestService.class));
>            }
>            return false;
>        }
>        @Override
>        public boolean onStopJob(JobParameters params) {
>            mJobScheduler.cancel(mJobID);
>    //        mJobScheduler.cancelAll();
>            return false;
>        }
>
>        /**
>         * 查询服务是否开启
>         * @param context
>         * @param serviceName
>         * @return
>         */
>        private boolean isServiceWork(Context context, String serviceName){
>            ActivityManager am= (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
>            List<ActivityManager.RunningServiceInfo> runningServices = am.getRunningServices(100);
>            if(runningServices == null){
>                return false;
>            }
>            for (ActivityManager.RunningServiceInfo service : runningServices) {
>                String className = service.service.getClassName();
>                if(className.equals(serviceName)){
>                    return true;
>                }
>            }
>            return false;
>        }
>```
>
>##### 4.5 定位
>
>定位完成，及时关闭
>如果需要实时定位，减少更新频率
>根据实际情况，选择gsp定位还是网络定位，降低电量消耗
>
>##### 4.6 **网络优化**
>
>手机的通过内置的射频模块和基站几乎, 从而链接上网的, 而这个射频模块(radio)是非常耗电的.
> 为了控制这个射频模块的耗电, 硬件驱动及Android RIL层做了很多处理. 例如可以单独关闭radio(飞行模式), 间歇性假休眠radio(有数据发生时才上电, 保持一个频率的与基站交互)等等.

### 5.网络优化

#### (1) 为什么要网络优化

>1.流量，虽然现在的wifi已经很普及，但还是有需要使用2G/3G/4G的的情况，那么流量是我们必须考虑的一部分（流量不便宜呀）
> 2.电量(重点)，电量是我们需要认真考虑的一方面，手机的续航能力是现在用户关注的一个点，如果手机电量消耗过快，用户可能会卸载那些消耗电量过大的应用。
> 3.响应时间(重点)，用户的体验是我们应用第一个目标，只有给用户好的体验，才能防止用户的流失。
> 4.安全（重点），网络数据传输的安全，是我们必须面对的一个问题，保护用户信息和数据的安全是我们的职责。

#### (2) 分析工具

>##### 2.1 **Network Monitor 介绍**
>
>Network Monitor 是Android Studio内置的网络监控工具。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/网络优化-image2.png)

>Rx --- Recive 表示下行流量
>
>Tx --- Transmit 表示上行流量
>
>##### 2.2 代理工具
>
>1.截获网络请求响应包, 分析网络请求
>2.设置代理网络
>
>Charles
>
>##### 2.3 模拟弱网

#### (3) 网络优化方案

>我们从任务的集中处理，传输数据优化，安全几个方面来讲解，最后在给出弱网情况下的一些建议
>
>###### 3.1 任务集中处理，节省流量,降低电量消耗
>
>这段内容在电量优化中已经讲过，这里不再重复太多，就对JobScheduler的使用在扩展下：
>
>```java
>JobInfo mJobInfo = new JobInfo.Builder(mJobID, new ComponentName(this, JobWakeUpService.class))
>            .setPeriodic(mIntervalMillis)//执行周期
>            .setMinimumLatency(mMinLatencyMillis)//最小延时
>            .setOverrideDeadline(mMaxExecutionDelayMillis)//最大执行时间
>            .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)//网络类型 NETWORK_TYPE_UNMETERED（wifi 蓝牙）
>            .setRequiresCharging(true) //充电时执行
>            //设置重试/退避策略 （重试时间，重试时间间隔）
>            .setBackoffCriteria(mInitialBackoffMillis, JobInfo.BACKOFF_POLICY_LINEAR)
>            .setPersisted(isPersisted)//设备重启，任务是否保留
>            .setRequiresDeviceIdle(isDeviceIdle)//设备空闲时
>            //监听url对应数据变化，触发当前任务执行
>            .addTriggerContentUri(mUrl)
>            //数据变化------->任务执行 最大延迟
>             .setTriggerContentMaxDelay(mDelay)
>            //更新 延迟
>           .setTriggerContentUpdateDelay(mUpdateDelay)
>            .build();
>```
>
>###### 3.2 传输数据优化，节省流量，响应更快
>
>- ###### gzip压缩
>
>	gzip 压缩 还是很常见的，在主流的网络访问框架中都有对应的api让你调用，我们以OKHttp为例：
>	gzip压缩拦截器：
>
>	```java
>	static class GzipRequestInterceptor implements Interceptor {
>	            @Override
>	            public Response intercept(Chain chain) throws IOException {
>	                okhttp3.Request originalRequest = chain.request();
>	                if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
>	                    return chain.proceed(originalRequest);
>	                }
>	
>	                okhttp3.Request compressedRequest = originalRequest.newBuilder()
>	                        .header("Content-Encoding", "gzip")
>	                        .method(originalRequest.method(), gzip(originalRequest.body()))
>	                        .build();
>	                return chain.proceed(compressedRequest);
>	            }
>	
>	            private RequestBody gzip(final okhttp3.RequestBody body) {
>	                return new RequestBody() {
>	                    @Override
>	                    public MediaType contentType() {
>	                        return body.contentType();
>	                    }
>	
>	                    @Override
>	                    public long contentLength() {
>	                        return -1; // 无法知道压缩后的数据大小
>	                    }
>	
>	                    @Override
>	                    public void writeTo(BufferedSink sink) throws IOException {
>	                        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
>	                        body.writeTo(gzipSink);
>	                        gzipSink.close();
>	                    }
>	                };
>	            }
>	        }
>	```
>
>- **代替JSON**
>
>	 使用Protocal Buffers，Nano-Proto-Buffers，FlatBuffer来减小序列化的数据的大小
>	Protocal Buffers,Nano-Proto-Buffers,FlatBuffers等相关知识可以在关于数据传输优化一章阅读，这里不再展开。
>
>- **缓存**
>
>	三级缓存还是很常用的，disk cache，mem cache,http cache,下面我们来分别聊一聊：
>
>	**http cache**
>
>	http协议自带的缓存策略，当资源没有修改时，http status 为304，可以看下下面的图：
>
>	![](/Users/candice/Documents/笔记/Android/内存优化/网络优化-image3.png)
>
>	ETag  请求变量的实体标签的当前值
>	 Last-Modified  请求资源的最后修改时间
>	 If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码
>	 If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变
>	 下面我们来看下Volley关于httpcache的使用：
>
>	```java
>	/**
>	 * 添加头---用于http缓存使用
>	 * @param headers
>	 * @param entry
>	 */
>	private void addCacheHeaders(Map<String, String> headers, Cache.Entry entry) {
>	    // If there's no cache entry, we're done.
>	    if (entry == null) {
>	        return;
>	    }
>	
>	    if (entry.etag != null) {
>	        headers.put("If-None-Match", entry.etag);
>	    }
>	
>	    if (entry.lastModified > 0) {
>	        Date refTime = new Date(entry.lastModified);
>	        headers.put("If-Modified-Since", DateUtils.formatDate(refTime));
>	    }
>	}
>	
>	```
>
>​      **memory cache**
>
>​	对于请求的是字符串或者json等文本的格式，是不需要内存缓存的。只有请求的是图片时才需要内存缓存对图片进行管理。对图片的管理使用LRU算法来进行管理。
>
>​     **disk cache**
>
>​     disk 缓存的实现大多数开源框架都是使用的jackwharton的杰作DiskLruCache
>
>- **图片压缩**

>##### 3.3 **不同的网络状况，做不同的事**
>
>​	在WiFi，4G，3G等不同的网络下设计不同大小的预取数据量，也可以是按照图片数量或者操作时间来作为阀值,我们还需要把当前的网络环境情况添加到设计预取数据量的策略当中去。判断当前设备的状态与网络情况,可以使用JobScheduler.
> 我们可以把网络请求延迟划分为三档：例如把网络延迟小于60ms的划分为GOOD，大于220ms的划分为BAD，介于两者之间的划分为OK（这里的60ms，220ms会需要根据不同的场景提前进行预算推测）。如果网络延迟属于GOOD的范畴，我们就可以做更多比较激进的预取数据的操作，如果网络延迟属于BAD的范畴，我们就应该考虑把当下的网络请求操作Hold住等待网络状况恢复到GOOD的状态再进行处理。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/网络优化-image4.png)

>![](/Users/candice/Documents/笔记/Android/内存优化/网络优化-image5.png)
>
>提示：使用AT&T提供的AT&T Network Attenuator来帮助预估网络延迟
>
>##### 3.4 **安全，保护用户信息**
>
>###### 主要针对两个问题：
>
>1.保证API的调用者是经过自己授权的App
> 2.保证数据传输的安全。
> 第一个问题：我主要采用设计签名的方式。对每个客户端，Android、iOS、WeChat，分别分配一个AppKey和AppSecret。需要调用API时，将AppKey加入请求参数列表，并将AppSecret和所有参数一起，根据某种签名算法生成一个签名字符串，然后调用API时把该签名字符串也一起带上。服务端收到请求之后，根据请求中的AppKey查询相应的AppSecret，按照同样的签名算法，也生成一个签名字符串，当服务端生成的签名和请求带过来的签名一致的时候，那就表示这个请求的调用者是经过自己授权的，证明这个请求是安全的。而且，每个端都有一个Key，也方便不同端的标识和统计。为了防止AppSecret被别人获取，这个AppSecret一般写死在代码里面。另外，签名算法也需要有一定的复杂度，不能轻易被别人破解，最好是采用自己规定的一套签名算法，而不是采用外部公开的签名算法。另外，在参数列表中再加入一个时间戳，还可以防止部分重放攻击。
> 第二个问题：主要就是采用HTTPS了。HTTPS因为添加了SSL安全协议，自动对请求数据进行了压缩加密，在一定程序可以防止监听、防止劫持、防止重发，主要就是防止中间人攻击。苹果从iOS9开始，默认就采用HTTPS了。而关于在Android中如何使用HTTPS，Google官方也给出了很多安全建议。不过，大部分App并没有按照安全建议去实现，主要就是没有对SSL证书进行安全性检查，这就成为了一个很大的漏洞，中间人利用此漏洞用假证书就可以通过检查，从而可以劫持到所有数据了。因此，为了安全考虑，建议对SSL证书进行强校验，包括签名CA是否合法、域名是否匹配、是不是自签名证书、证书是否过期等。
>
>##### 3.5 **弱网情况下我们应该做些什么？**
>
>1).压缩/减少数据传输量
>(2).利用缓存减少网络传输
>(3).针对弱网(移动网络), 不自动加载图片
>(4).界面先反馈, 请求延迟提交

### 6.Bitmap优化

内存溢出的主要原因之一。

#### (1) 使用注意点

>当我们需要获取图片的宽高等属性时且不对数据进行操作，那么我们不应该把图片的数据加载到内存中，这时我们可以设置inJustDecodeBounds属性为true.
>
>```java
>BitmapFactory.Options opt=new BitmapFactory.Options();
>    opt.inJustDecodeBounds=true;
>    BitmapFactory.decodeFile(filePath, opt);
>    final int height = options.outHeight;
>    final int width = options.outWidth;
>```

#### (2) 减小Bitmap对象的内存占用

>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：
> 1.inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。
> 2.decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。
>
>```java
>    /**
> *   根据文件路径得到压缩的图片
> * @param filePath   文件路径
> * @param reqHeight  目标高
> * @param reqWidth   目标宽
> * @param config   options.inPreferredConfig=Config.RGB_565
> * @return
> */
>public static Bitmap  getSmallImageForFile(String filePath,int reqHeight,int reqWidth,Config config){
>    BitmapFactory.Options opt=new BitmapFactory.Options();
>    opt.inJustDecodeBounds=true;
>    BitmapFactory.decodeFile(filePath, opt);
>    int inSampleSize = calacteInSampleSize(opt,reqHeight,reqWidth);
>    opt.inPurgeable = true;
>    opt.inInputShareable = true;
>    opt.inPreferredConfig=config;
>    opt.inJustDecodeBounds=false;
>    Bitmap bitmap = BitmapFactory.decodeFile(filePath, opt);
>    return  bitmap;
>} 
>/**
> * 计算缩放的值
> * @param options    BitmapFactory.Options
> * @param reqheight  目标高
> * @param reqWidth    目标宽
> */
>public static int  calacteInSampleSize(BitmapFactory.Options options,int reqheight,int reqWidth){
>    final int height = options.outHeight;
>    final int width = options.outWidth;
>    int inSampleSize = 1;
>    if (width > reqWidth || height > reqheight) {
>        if (width > height) {
>            inSampleSize = Math.round((float) height / (float) reqheight);
>        } else {
>            inSampleSize = Math.round((float) width / (float) reqWidth);
>        }
>        final float totalPixels = width * height;
>        final float maxTotalPixels = reqWidth * reqheight * 2;
>        while (totalPixels / (inSampleSize * inSampleSize) > maxTotalPixels) {
>            inSampleSize++;
>        }
>    }
>    return inSampleSize;
>}
>```
>
>可以对当前Bitmap生产缩略图
>
>```java
>Bitmap thumbnailBitmap = ThumbnailUtils.extractThumbnail(bitmap, reqWidth, reqHeight,  
>                ThumbnailUtils.OPTIONS_RECYCLE_INPUT);
>```

#### (3) **Bitmap对象的复用**

>​	我们知道大多数对象的复用，最终实施的方案都是利用对象池技术，要么是在编写代码的时候显式的在程序里面去创建对象池，然后处理好复用的实现逻辑，要么就是利用系统框架既有的某些复用特性达到减少对象的重复创建，从而减少内存的分配与回收。
> 在Bitmap中，利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率上的提升(3.0以及4.4以后存在一些使用限制上的差异)。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。

![](/Users/candice/Documents/笔记/Android/内存优化/Bitmap-iamge1.png)

>
>
>使用inBitmap需要注意几个限制条件：
>
>###### (1).在SDK 11 -> 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小
>
>###### (2).新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。 我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。

#### (4) Bitmap对象及时回收

>虽然在大多数情况下，我们会对Bitmap增加缓存机制，但是在某些时候，部分Bitmap是需要及时回收的。例如临时创建的某个相对比较大的bitmap对象，在经过变换得到新的bitmap对象之后，应该尽快回收原始的bitmap，这样能够更快释放原始bitmap所占用的空间。

#### (5) LRU管理Bitmap

>LRU是Least Recently Used 近期最少使用算法。其实LruCache的作用就是对缓存的元素进行排序，当超过设定的内存值时就会将使用最少，使用最早元素先回收。
> 使用Lru来管理Bitmap,设置最大内存，可以防止出现内存溢出。
> 相关源码可以看[LruCache使用以及源码详细解析](https://blog.csdn.net/a847427920/article/details/52206165)

#### (6) 直接使用更小的图片

>###### 1).我们可以在获取图片时告知服务器需要的图片的宽高, 以便服务器给出合适的图片, 避免浪费.
>
>以七牛为例, 可以在请求图片的url中添加诸如质量, 格式, width, height等path来获取合适的图片资源.[七牛](https://developer.qiniu.com/dora/manual/1279/basic-processing-images-imageview2)
>
>###### (2).使用本地图片压缩
>
>关于图片压缩，将会在下一篇中讲解。

### 7 图片压缩优化

#### (1) 降压采样率压缩

```java
BitmapFactory.Options o = new BitmapFactory.Options();
 o.inJustDecodeBounds = true;
 BitmapFactory.decodeFile(path, o);
 o.inSampleSize=自己计算
 o.inJustDecodeBounds = false;
 BitmapFactory.decodeFile(path, o);
```

#### (2) 质量压缩

```java
bitmap.compress(Bitmap.CompressFormat.JPEG, 20, new FileOutputStream("sdcard/result.jpg"));
```

相信大家都用过，但是压缩比例很小，如果压缩的太多，就会导致图片失真，但是我发发现IOS系统上的图片只有100k,200k左右却很清晰，它们用的什么方式来压缩的呢？
今天我们就来使用jpeg的方式来进行对图片压缩：

#### (3) jepg压缩

>##### 3.1准备工作
>
>###### (1).ndk工具包下载可以到<http://www.androiddevtools.cn/> 下载解压就行了
>
>###### (2).libjpeg库源码下载
>
>```
>git clone git://git.linaro.org/people/tomgall/libjpeg-turbo/libjpeg-turbo.git -b linaro-android  
>```
>
>**(3).用ndk命令进行编译**
>
>```
>ndk-build APP_ABI=armeabi-v7a,armeabi 
>```
>
>##### 3.2 编写代码
>
>- **把动态库和头文件添加到我们项目中**
>
>![](/Users/candice/Documents/笔记/Android/内存优化/jepg-image1.png)

>- **编写java层代码**
>
>- ```java
>	public class ImageUtil {
>	        static {
>	            System.loadLibrary("compressImage");
>	        }
>	        /**
>	         * 使用libjpeg进行压缩
>	         * @param bitmap   压缩的图片
>	         * @param quality   质量
>	         * @param dstFile   新的图片路径
>	         * @param optimize  是否使用哈夫曼算法完成压缩（使用哈夫曼算法压缩，压缩率高10~25倍）
>	         * @return   是否压缩成功
>	         */
>	        public static boolean compressImage(Bitmap bitmap,int quality,String dstFile,boolean  optimize){
>	            int ret = compressBitmap( bitmap, quality, dstFile,  optimize);
>	            return  ret==1;
>	        }
>	        public static native int compressBitmap(Bitmap bitmap, int quality, String dstFile,boolean  optimize);
>	```
>
>- **生成头文件**
>
>- ```
>	javah -classpath . -jni github.com.androidadvanced_ndk.util.ImageUtil
>	```
>
>- **编写cmake和配置gradle**
>
>  **cmake**
>
>- ```c
>	cmake_minimum_required(VERSION 3.4.1)
>	
>	    set(distribution_DIR ../../../../libs )
>	    set(SOURCE_FILES src/main/cpp/compressImage.cpp)
>	    set(INC_DIR src/main/cpp/include)
>	
>	    include_directories(src/main/cpp/include)
>	
>	    find_library(   log-lib
>	                    log )
>	    find_library(graphics jnigraphics)
>	
>	    add_library(    libjpeg
>	                    SHARED
>	                     IMPORTED )
>	
>	    set_target_properties(  libjpeg
>	                            PROPERTIES IMPORTED_LOCATION
>	                            ${distribution_DIR}/${ANDROID_ABI}/libjpeg.so)
>	
>	    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=gnu++11")
>	
>	    add_library(    compressImage
>	                    SHARED
>	                    ${SOURCE_FILES} )
>	
>	    target_link_libraries(  compressImage
>	                            libjpeg
>	                            ${log-lib}
>	                            ${graphics})
>	```
>
>build.gradle
>
>```groovy
>  ndk{
>        abiFilters "armeabi-v7a" ,"armeabi"
>    }
>
>    sourceSets {
>    main {
>        jniLibs.srcDirs = ['libs']
>      }
>    } 
>```
>
>- **编写c代码**
>
>- ```c
>	#include <jni.h>
>	    #include <string>
>	    #include <stdlib.h>
>	    #include "github_com_androidadvanced_ndk_util_ImageUtil.h"
>	    #include <unistd.h>
>	    #include <setjmp.h>
>	    #include <android/bitmap.h>
>	    #include <android/log.h>
>	    #define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,"imagecompress",FORMAT,##__VA_ARGS__);
>	    #define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,"imagecompress",FORMAT,##__VA_ARGS__);
>	    #define LOGW(FORMAT,...) __android_log_print(ANDROID_LOG_WARN,"imagecompress",FORMAT,##__VA_ARGS__);
>	    #define LOGD(FORMAT,...) __android_log_print(ANDROID_LOG_DEBUG,"imagecompress",FORMAT,##__VA_ARGS__);
>	
>	    typedef u_int8_t BYTE;
>	    struct my_error_mgr {
>	        struct jpeg_error_mgr pub;
>	        jmp_buf setjmp_buffer;
>	    };
>	
>	    typedef struct my_error_mgr *my_error_ptr;
>	
>	    METHODDEF(void)
>	    my_error_exit(j_common_ptr
>	                  cinfo) {
>	        my_error_ptr myerr = (my_error_ptr) cinfo->err;
>	        (*cinfo->err->output_message)(cinfo);
>	        LOGW("jpeg_message_table[%d]:%s",
>	             myerr->pub.msg_code, myerr->pub.jpeg_message_table[myerr->pub.msg_code]);
>	        longjmp(myerr
>	                        ->setjmp_buffer, 1);
>	    };
>	/**
>	     * 压缩的数据    宽  高  压缩质量  存放路径    是否使用哈夫曼算法完成压缩
>	     */
>	    int generateJPEG(BYTE *data, int w, int h, jint quality, const char *name, boolean optimize);
>	
>	    int generateJPEG(BYTE *data, int w, int h, int quality, const char *name, boolean optimize) {
>	        int nComponent = 3;
>	        struct jpeg_compress_struct jcs;
>	        //自定义的error
>	        struct my_error_mgr jem;
>	        jcs.err = jpeg_std_error(&jem.pub);
>	        jem.pub.error_exit = my_error_exit;
>	
>	        if (setjmp(jem.setjmp_buffer)) {
>	            return 0;
>	        }
>	        //为JPEG对象分配空间并初始化
>	        jpeg_create_compress(&jcs);
>	        //获取文件信息
>	        FILE *f = fopen(name, "wb");
>	        if (f == NULL) {
>	            return 0;
>	        }       
>	        //指定压缩数据源
>	        jpeg_stdio_dest(&jcs, f);
>	        jcs.image_width = w;
>	        jcs.image_height = h;
>	        jcs.arith_code = false;
>	        jcs.input_components = nComponent;
>	        jcs.in_color_space = JCS_RGB;
>	        jpeg_set_defaults(&jcs);
>	        jcs.optimize_coding = optimize;
>	//为压缩设定参数，包括图像大小，颜色空间
>	        jpeg_set_quality(&jcs, quality, true);
>	        //开始压缩
>	        jpeg_start_compress(&jcs, true);
>	        JSAMPROW row_point[1];
>	        int row_stride;
>	        row_stride = jcs.image_width * nComponent;
>	        while (jcs.next_scanline < jcs.image_height) {
>	            row_point[0] = &data[jcs.next_scanline * row_stride];
>	            jpeg_write_scanlines(&jcs, row_point, 1);
>	        }
>	
>	        if (jcs.optimize_coding) {
>	            LOGI("使用了哈夫曼算法完成压缩");
>	        } else {
>	            LOGI("未使用哈夫曼算法");
>	        }
>	        //压缩完毕
>	        jpeg_finish_compress(&jcs);
>	        //释放资源
>	        jpeg_destroy_compress(&jcs);
>	        fclose(f);
>	        return 1;
>	    }
>	    /*
>	     * Class:     github_com_androidadvanced_ndk_util_ImageUtil
>	     * Method:    compressBitmap
>	     * Signature: (Ljava/lang/Object;ILjava/lang/String;B)I
>	     */
>	    JNIEXPORT jint JNICALL Java_github_com_androidadvanced_1ndk_util_ImageUtil_compressBitmap
>	            (JNIEnv * env, jclass clazz, jobject bitmap, jint quality, jstring dstFile,jboolean optimize){
>	
>	        LOGE("%s", "===>Java_github_com_androidadvanced_1ndk_util_ImageUtil_compressBitmap");
>	        int ret;
>	        AndroidBitmapInfo bitmapInfo;
>	        //像素点argb
>	        BYTE *pixelsColor;
>	        //bitmap 数据
>	        BYTE *data;
>	        BYTE *tmpData;
>	
>	        //获取android bitmap 信息
>	        if((ret = AndroidBitmap_getInfo(env,bitmap,&bitmapInfo)) < 0){
>	            LOGD("AndroidBitmap_getInfo() failed error=%d", ret);
>	            return ret;
>	        }
>	
>	        //锁定bitmap,获取像素点argb，存储到pixelsColor中
>	        if((ret = AndroidBitmap_lockPixels(env,bitmap,(void**)&pixelsColor)) < 0){
>	            LOGD("AndroidBitmap_lockPixels() failed error=%d", ret);
>	            return ret;
>	        }
>	        BYTE r, g, b;
>	        int color;
>	        //获取图片信息
>	        int w, h, format;
>	        w = bitmapInfo.width;
>	        h = bitmapInfo.height;
>	        format = bitmapInfo.format;
>	        //只处理 RGBA_8888
>	        if(format != ANDROID_BITMAP_FORMAT_RGBA_8888){
>	            LOGD("AndroidBitmapInfo  format  is not ANDROID_BITMAP_FORMAT_RGBA_8888 error=%d", ret);
>	            return -1;
>	        }
>	
>	        LOGD("bitmap: width=%d,height=%d,size=%d , format=%d ", w,h,w*h,bitmapInfo.format);
>	//分配内存（存放bitmap rgb数据）
>	        data = (BYTE *) malloc(w * h * 3);
>	        //保存内存首地址
>	        tmpData=data;
>	        //将bitmap转rgb
>	        int i=0;
>	        int j=0;
>	        for (i = 0; i < h; ++i) {
>	            for (j = 0; j < w; ++j){
>	                //像素点
>	                color = *((int*) pixelsColor);
>	                //取argb值（各占8位）    0xffffffff--->0xaarrggbb
>	                r= (color >> 16) & 0xff;
>	                g= (color >> 8) & 0xff;
>	                b= (color >> 0) & 0xff;
>	
>	                *data=b;
>	                *(data+1)=g;
>	                *(data+2)=r;
>	
>	                //data只存rgb
>	                data+=3;
>	                //pixelsColor中存的是argb
>	                pixelsColor+=4;     
>	            }
>	        }
>	        AndroidBitmap_unlockPixels(env,bitmap);     
>	        //进行压缩
>	        const char* file_path = env->GetStringUTFChars(dstFile,NULL);
>	
>	        //压缩图片
>	        ret = generateJPEG(tmpData,w,h,quality,file_path,optimize);
>	
>	        //释放内存
>	        free((void *) tmpData);
>	        env->ReleaseStringUTFChars(dstFile,file_path);
>	
>	        //释放java-->bitmap
>	        jclass  jBitmapClass = env->GetObjectClass(bitmap);
>	        jmethodID jRecycleMethodId = env->GetMethodID(jBitmapClass,"recycle","()V");
>	        env->CallVoidMethod(bitmap,jRecycleMethodId,NULL);
>	
>	        return ret;
>	    }
>	```

>- **使用**
>
>- ```java
>	 //线程安全
>	    CopyOnWriteArrayList<String> compressImageList=new CopyOnWriteArrayList<>();
>	    //开线程池
>	    ThreadPoolManager.ThreadPool threadPool = ThreadPoolManager.getInstance().getShortTreadPool();
>	    for (final String imagePath : imageList) {
>	        final String temFilePath = temDir + File.separator + new File(imagePath).getName();
>	        threadPool.excute(new Runnable() {
>	            @Override
>	            public void run() {
>	                Bitmap bitmap = ImageUtil.decodeFile(imagePath);
>	                if(ImageUtil.compressImage(bitmap,65,temFilePath,true)){
>	                    compressImageList.add(temFilePath);
>	                }
>	                if(bitmap != null) {
>	                    bitmap.recycle();
>	                }
>	            }
>	        });
>	    }
>	```
>
>- **效果**
>
>压缩前

![](/Users/candice/Documents/笔记/Android/内存优化/jepg-image2.png)

>压缩后大小

![](/Users/candice/Documents/笔记/Android/内存优化/jepg-image3.png)

>GitHub地址：https://github.com/skcodestack/StoneImageCompress-Demo

### 8. 多线程并发优化

#### (1) Thread的使用

>**Thread注意点**
>
>##### 1.1 Thread中断
>
>**常用方式**
>
>- **通过抛出InterruptedException来中断线程**
>
>- ```java
>	public  static  class  MyThread extends Thread{
>	        private  int count=0;
>	        @Override
>	        public void run() {
>	            super.run();
>	            try{
>	                while(true){
>	                        count++;
>	                        System.out.println("count value:"+count);
>	                        if (this.interrupted() || this.isInterrupted()){
>	                            System.out.println("check interrupted show!");
>	                            throw new InterruptedException();
>	                        }
>	                }
>	            }catch ( InterruptedException e) {
>	                System.out.println("thread is stop!");
>	                e.printStackTrace();
>	            }
>	        }
>	        
>	    } 
>	```
>
>- **通过变量来中断（常用）**
>
>- ```java
>	public  static  class  CustomThread extends Thread{
>	        private  int count=0;
>	        private boolean isCancel = false;
>	        @Override
>	        public void run() {
>	            super.run();
>	            while(!isCancel){
>	                    count++;
>	                    System.out.println("count value:"+count);
>	            }
>	        }
>	        
>	        public synchronized void cancel(){
>	            isCancel = true;
>	        }
>	    } 
>	```
>
>##### 1.2 同步
>
>- **变量同步**
>
>	**使用volatile关键字**
>
>	```java
>	    /**
>	     * 主内存和线程内存缓存进行同步
>	     */
>	    volatile int val = 5;
>	    public int getVal() {
>	        return val;
>	    }
>	    public void setVal(int val) {
>	        this.val = val;
>	    }
>	```
>
>	**使用synchronized关键字**
>
>	```java
>	int val2 = 5;
>	    /**
>	     * 使用一个motinor来监听（实现资源由一个线程进行操作）
>	     * 主内存和线程内存缓存进行同步
>	     * @return
>	     */
>	    public synchronized int getVal2() {
>	        return val2;
>	    }
>	    public synchronized int setVal2(int val) {
>	        this.val2 = val;
>	    }
>	```
>
>	**使用关键字AtomicXXXXX**
>
>	```java
>	    AtomicInteger mAtomicValue = new  AtomicInteger(0);
>	    public void setAtomicValue(int value){
>	        mAtomicValue.getAndSet(value);
>	    }
>	    public int getAtomicValue(){
>	        return mAtomicValue.get();
>	    }
>	```
>
>- **代码块同步**
>
>	代码块同步分乐观锁和悲观锁来讲解
>
>	使用悲观锁时，其它线程等待，进入睡眠，频繁切换任务，消耗CPU资源。
>
>	```java
>	    synchronized (this) {
>	        .....   
>	    }
>	```
>
>	使用乐观锁时，失败重试，避免任务重复切换，减少CPU消耗
>
>	```java
>	ReentrantLock lock = new  ReentrantLock();
>	    lock.lock();
>	    ......
>	    lock.unlock();
>	```
>
>#### (2) Android Thread
>
>​	android中很多操作需要在主线程中执行，比如UI的操作，点击事件等等，但是如果主线程操作太多，占有的执行时间过长就会出现前面我们说的卡顿现象。为了减轻主线程操作过多，避免出现卡顿的现象，我们把一些操作复杂的消耗时间长的任务放到线程池中去执行。
>
>##### 2.1 **AsyncTask**
>
>为UI线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。
> 它提供了一种简便的异步处理机制，但是它又同时引入了一些令人厌恶的麻烦。一旦对AsyncTask使用不当，很可能对程序的性能带来负面影响，同时还可能导致内存泄露。
>
>**注意的问题**
>
>- **在AsyncTask中所有的任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。一旦有任务执行时间过长，队列中其他任务就会阻塞。**

![](/Users/candice/Documents/笔记/Android/内存优化/NetWork-image1.png)

>对于上面的问题，我们可以使用AsyncTask.executeOnExecutor()让AsyncTask变成并发调度。
>
>- ###### AsyncTask对正在执行的任务不具备取消的功能，所以我们要在任务代码中添加取消的逻辑（和上面Thread类似）
>
>- ###### AsyncTask使用不当会导致内存泄漏
>
>##### 2.2 HandleThread
>
>为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。
> 先来了解下Looper，Handler，MessageQueue
> Looper: 能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。
> Handler: 能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。
> MessageQueue: 使用Intent，Message，Runnable作为任务的载体在不同的线程之间进行传递。
> 把上面三个组件打包到一起进行协作，这就是HandlerThread

![](/Users/candice/Documents/笔记/Android/内存优化/NetWork-image2.png)

>```java
>    public class HandlerThread extends Thread {
>        public HandlerThread(String name, int priority) {
>            super(name);
>            mPriority = priority;
>        }
>
>        @Override
>        public void run() {
>            mTid = Process.myTid();
>            Looper.prepare();
>            synchronized (this) {
>                mLooper = Looper.myLooper();
>                notifyAll();
>            }
>            Process.setThreadPriority(mPriority);
>            onLooperPrepared();
>            Looper.loop();
>            mTid = -1;
>        }
>
>        public Looper getLooper() {
>            if (!isAlive()) {
>                return null;
>            }
>            // If the thread has been started, wait until the looper has been created.
>            synchronized (this) {
>                while (isAlive() && mLooper == null) {
>                    try {
>                        wait();
>                    } catch (InterruptedException e) {
>                    }
>                }
>            }
>            return mLooper;
>        }
>    }
>```
>
>**HandlerThread其实就是在线程中维持一个消息循环队列。**
>
>```java
>    HandlerThread mHanderThread = new HandlerThread("hanlderThreadTest", Process.THREAD_PRIORITY_BACKGROUND);
>    mHanderThread.run();
>    Looper mHanderThreadLooper = mHanderThread.getLooper();
>
>    Handler mHandler = new Handler(mHanderThreadLooper){
>        @Override
>        public void handleMessage(Message msg) {
>            super.handleMessage(msg);
>            //子线程中执行
>            ...
>        }
>    };
>    //发送消息
>    mHandler.post(new Runnable() {
>        @Override
>        public void run() {
>            ...
>        }
>    });  
>```
>
>##### 2.3 **IntentService**
>
>适合于执行由UI触发的后台Service任务，并可以把后台任务执行的情况通过一定的机制反馈给UI。
> 默认的Service是执行在主线程的，可是通常情况下，这很容易影响到程序的绘制性能(抢占了主线程的资源)。除了前面介绍过的AsyncTask与HandlerThread，我们还可以选择使用IntentService来实现异步操作。IntentService继承自普通Service同时又在内部创建了一个HandlerThread，在onHandlerIntent()的回调里面处理扔到IntentService的任务。所以IntentService就不仅仅具备了异步线程的特性，还同时保留了Service不受主页面生命周期影响的特点。

![](/Users/candice/Documents/笔记/Android/内存优化/NetWork-image3.png)

>###### 使用IntentService需要特别注意的点：
>
>- ###### 因为IntentService内置的是HandlerThread作为异步线程，所以每一个交给IntentService的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。
>
>- ###### 通常使用到IntentService的时候，我们会结合使用BroadcastReceiver把工作线程的任务执行结果返回给主UI线程。使用广播容易引起性能问题，我们可以使用LocalBroadcastManager来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用runOnUiThread()快速回调到主UI线程。
>
>- ###### 包含正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。
>
>###### 2.4 Loader
>
>对于3.0后ContentProvider中的耗时操作，推荐使用Loader异步加载数据机制。相对其他加载机制，Loader有那些优点呢？
>
>- 提供异步加载数据机制
>- 对数据源变化进行监听，实时更新数据
>- 在Activity配置发生变化（如横竖屏切换）时不用重复加载数据
>- 适用于任何Activity和Fragment
>	 下面我们来看下Loader的具体使用：
>	 我们以获得手机中所有的图片为例：
>
>```java
>    getLoaderManager().initLoader(LOADER_TYPE, null, mLoaderCallback);
>    LoaderManager.LoaderCallbacks<Cursor> mLoaderCallback = new LoaderManager.LoaderCallbacks<Cursor>() {
>        private final String[] IMAGE_COLUMNS={
>                MediaStore.Images.Media.DATA,//图片路径
>                MediaStore.Images.Media.DISPLAY_NAME,//显示的名字
>                MediaStore.Images.Media.DATE_ADDED,//添加时间
>                MediaStore.Images.Media.MIME_TYPE,//图片扩展类型
>                MediaStore.Images.Media.SIZE,//图片大小
>                MediaStore.Images.Media._ID,//图片id
>        };
>
>        @Override
>        public Loader<Cursor> onCreateLoader(int id, Bundle args) {
>            toggleShowLoading(true,getString(R.string.common_loading));
>
>            CursorLoader cursorLoader = new CursorLoader(ImageSelectActivity.this,                 MediaStore.Images.Media.EXTERNAL_CONTENT_URI,IMAGE_COLUMNS,
>                    IMAGE_COLUMNS[4] + " > 0 AND "+IMAGE_COLUMNS[3] + " =? OR " +IMAGE_COLUMNS[3] + " =? ",
>                    new String[]{"image/jpeg","image/png"},IMAGE_COLUMNS[2] + " DESC");
>            return cursorLoader;
>        }
>@Override
>        public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
>            if(data != null && data.getCount() > 0){
>                ArrayList<String> imageList = new ArrayList<>();
>
>                if(mShowCamera){
>                    imageList.add("");
>                }
>                while (data.moveToNext()){
>                    String path = data.getString(data.getColumnIndexOrThrow(IMAGE_COLUMNS[0]));
>                    imageList.add(path);
>                    Log.e("ImageSelect", "IIIIIIIIIIIIIIIIIIII=====>"+path);
>                }
>                //显示数据
>                showListData(imageList);
>                toggleShowLoading(false,getString(R.string.common_loading));
>            }
>        }
>
>        @Override
>        public void onLoaderReset(Loader<Cursor> loader) {  
>        }
>```
>
>onCreateLoader()  实例化并返回一个新创建给定ID的Loader对象
> onLoadFinished() 当创建好的Loader完成了数据的load之后回调此方法
> onLoaderReset() 当创建好的Loader被reset时调用此方法，这样保证它的数据无效
> LoaderManager会对查询的操作进行缓存，只要对应Cursor上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader可以直接把缓存的数据回调到onLoadFinished()，从而避免重新查询数据。另外系统会在Loader不再需要使用到的时候(例如使用Back按钮退出当前页面)回调onLoaderReset()方法，我们可以在这里做数据的清除等等操作。
>
>##### 2.5 **ThreadPool**
>
>把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。
>线程池适合用在把任务进行分解，并发进行执行的场景。
>系统提供ThreadPoolExecutor帮助类来帮助我们简化实现线程池。

![](/Users/candice/Documents/笔记/Android/内存优化/NetWork-image4.png)

>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为CPU只能同时执行固定数量的线程数，一旦同时并发的线程数量超过CPU能够同时执行的阈值，CPU就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。
> 一旦同时并发的线程数量达到一定的量级，这个时候CPU在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少64K+的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。
>
>```java
>/**
>     * 核心线程数
>     * 最大线程数
>     * 保活时间
>     * 时间单位
>     * 任务队列
>     * 线程工厂
>     */
>    threadPoolExecutor = new ThreadPoolExecutor(
>            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
>            linkedBlockingQueue, sThreadFactory);
>    threadPoolExecutor.execute(runnable);
>```
>
>###### 我们知道系统还提供了Executors类中几种线程池，下面我们来看下这些线程池的缺点：
>
>newFixedThreadPool 和 newSingleThreadExecutor:主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。
> newCachedThreadPool 和 newScheduledThreadPool:主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。

#### (3) 线程优先级

>Android系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为forground的那部分线程会大致占用掉CPU的90%左右的时间片，background的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为forground的程序本身的优先级就更高，理应得到更多的执行时间。

![](/Users/candice/Documents/笔记/Android/内存优化/ NetWork-image5.png)

> 默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主UI线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占CPU资源，需要把这些线程的优先级进行降低处理，这样才能给帮组CPU识别主次，提高主线程所能得到的系统资源。
>
> 在Android系统里面，我们可以通过android.os.Process.setThreadPriority(int)设置线程的优先级，参数范围从-20到24，数值越小优先级越高。Android系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。

![](/Users/candice/Documents/笔记/Android/内存优化/NetWork-image6.png)

>**大多数情况下，新创建的线程优先级会被设置为默认的0，主线程设置为0的时候，新创建的线程还可以利用THREAD_PRIORITY_LESS_FAVORABLE或者THREAD_PRIORITY_MORE_FAVORABLE来控制线程的优先级。**

### 9.数据传输效率优化

#### (1) 数据的序列化

​	数据序列化的行为可能发生在数据传递过程中的任何阶段，例如网络传输，不同进程间数据传递，不同类之间的参数传递，把数据存储到磁盘上等等。

**什么是序列化和反序列化？**

​	简单来说就是将对象转换为可以传输的二进制流(二进制序列)的过程,这样我们就可以通过序列化,转化为可以在网络传输或者保存到本地的流(序列),从而进行传输数据 ,那反序列化就是从二进制流(序列)转化为对象的过程.

>##### 1.1 Serializable
>
>Serializable是我们平时使用比较多的，但是这种传统的做法效率不高，实施的过程会消耗更多的内存。
>
>```java
>public class CompanyInfo implements Serializable {}
>```
>
>**序列化**
>
>```java
>        out = new FileOutputStream(mSerializeFile);
>        CompanyInfo companyInfo = new CompanyInfo(1001, "常州网络有限公司");
>        objectOutputStream = new ObjectOutputStream(out);
>        objectOutputStream.writeObject(companyInfo);
>```
>
>**反序列化**
>
>```java
>        fIn = new FileInputStream(mSerializeFile);
>        objectInputStream = new ObjectInputStream(fIn);
>        Object object
>                = objectInputStream.readObject();
>        if(object instanceof CompanyInfo){
>            CompanyInfo info = (CompanyInfo) object;
>        }
>```
>
>##### 1.2 **Parcelable**
>
>Parcelable是Android为我们提供的序列化的接口,Parcelable相对于Serializable的使用相对复杂一些,但Parcelable的效率相对Serializable也高很多
>
>```java
>public class PersonInfo implements Parcelable 
>```
>
>**序列化**
>
>```java
>    @Override
>    public void writeToParcel(Parcel dest, int flags) {
>        dest.writeInt(id);
>        dest.writeString(name);
>        dest.writeString(love);
>    }
>```
>
>**反序列化**
>
>```java
>protected PersonInfo(Parcel in) {
>        id = in.readInt();
>        name = in.readString();
>        love = in.readString();
>    }
>    public static final Creator<PersonInfo> CREATOR = new Creator<PersonInfo>() {
>        @Override
>        public PersonInfo createFromParcel(Parcel in) {
>            return new PersonInfo(in);
>        }
>        @Override
>        public PersonInfo[] newArray(int size) {
>            return new PersonInfo[size];
>        }
>    };
>```
>
>##### 1.3 Gson
>
>GSON库来处理这个序列化的问题，不仅仅执行速度更快，内存的使用效率也更高。

![](/Users/candice/Documents/笔记/Android/内存优化/Data-image1.png)

>###### 下面介绍三个数据序列化的候选方案：
>
>- Protocal Buffers：强大，灵活，但是对内存的消耗会比较大，并不是移动终端上的最佳选择。
>- Nano-Proto-Buffers：基于Protocal，为移动终端做了特殊的优化，代码执行效率更高，内存使用效率更佳。
>- FlatBuffers：这个开源库最开始是由Google研发的，专注于提供更优秀的性能。

![](/Users/candice/Documents/笔记/Android/内存优化/Data-iamge2.png)

![](/Users/candice/Documents/笔记/Android/内存优化/Data-image3.png)

>FlatBuffers 几乎从空间和时间复杂度上完胜其他技术。
> FlatBuffers 是一个开源的跨平台数据序列化库，可以应用到几乎任何语言（C++, C#, Go, Java, JavaScript, PHP, Python），最开始是 Google 为游戏或者其他对性能要求很高的应用开发的。

#### (2) FlatBuffers

>##### 2.1优点
>
>- 直接读取序列化数据，而不需要解析（Parsing）或者解包（Unpacking）：FlatBuffer 把数据层级结构保存在一个扁平化的二进制缓存（一维数组）中，同时能够保持直接获取里面的结构化数据，而不需要解析，并且还能保证数据结构变化的前后向兼容。
>
>- 高效的内存使用和速度：FlatBuffer 使用过程中，不需要额外的内存，几乎接近原始数据在内存中的大小。
>
>- 灵活：数据能够前后向兼容，并且能够灵活控制你的数据结构。
>
>- 很少的代码侵入性：使用少量的自动生成的代码即可实现。
>
>- 强数据类性，易于使用，跨平台，几乎语言无关。

![](/Users/candice/Documents/WorkSpace/ASProjects/InterviewQuestionofAndroid/app/pics/性能优化/FlatBuffers-image1.png)

>​	在做 Android 开发的时候，JSON 是最常用的数据序列化技术。我们知道，JSON 的可读性很强，但是序列化和反序列化性能却是最差的。解析的时候，JSON 解析器首先，需要在内存中初始化一个对应的数据结构，这个事件经常会消耗 100ms ~ 200ms；解析过程中，要产生大量的临时变量，造成 Java 虚拟机的 GC 和内存抖动，解析 20KB 的数据，大概会消耗 100KB 的临时内存。FlatBuffers 就解决了这些问题。
>
>##### 2.2 **FlatBuffers缺点**
>
>(1).FlatBuffers 需要生成代码，对代码有侵入性
> (2).数据序列化没有可读性，不方便 Debug；
> (3).构建 FlatBuffers 对象比较麻烦，不直观，特别是如果对象比较复杂情况下需要写大段的代码；
> (4).数据的所有内容需要使用 Schema 严格定义，灵活性不如 JSON。
>
>##### 2.3 原理
>
>​	官方文档的介绍，FlatBuffers 就像它的名字所表示的一样，就是把结构化的对象，用一个扁平化（Flat）的缓冲区保存，简单的来说就是把内存对象数据，保存在一个一维的数组中。借用 Facebook 文章2的一张图如下：

![](/Users/candice/Documents/WorkSpace/ASProjects/InterviewQuestionofAndroid/app/pics/性能优化/FlatBuffers-image2.png)

>​	可见，FlatBuffers 保存在一个 byte 数组中，有一个“支点”指针（pivot point）以此为界，存储的内容分为两个部分：元数据和数据内容。其中元数据部分就是数据在前面，其长度等于对象中的字段数量，每个 byte 保存对应字段内容在数组中的索引（从支点位置开始计算）。
> 如图，上面的 Person 对象第一个字段是 name，其值的索引位置是 1，所以从索引位置 1 开始的字符串，就是 name 字段的值 "John"。第二个字段是 friendshipStatus，其索引值是 6，找到值为 2， 表示 NotFriend。第三个字段是 spouse，也一个 Person 对象，索引值是 12，指向的是此对象的支点位置。第四个字段是一个数组，图中表示的数组为空，所以索引值是 0。
>
>**通过上面的解析，可以看出，FlatBuffers 通过自己分配和管理对象的存储，使对象在内存中就是线性结构化的，直接可以把内存内容保存或者发送出去，加载“解析”数据只需要把 byte 数组加载到内存中即可，不需要任何解析，也不产生任何中间变量。**
>
>​	它与具体的机器或者运行环境无关，例如在 Java 中，对象内的内存不依赖 Java 虚拟机的堆内存分配策略实现，所以也是跨平台的。
>
>##### 2.4 使用步骤
>
>- **定义数据结构Schema**
>
>```
>    namespace Character;
>    table Items{
>        items:[Basic];
>        itemId:long;
>        timestemp:long;
>    }
>    table Basic{
>        id:long;
>        name:string;
>        email:string;
>        code:long;
>        isVip:bool;
>        count:int;
>        headUrl:string (deprecated);
>        carList:[Car];
>    }
>    table Car{
>        id:long;
>        number:long;
>        describle:string;
>    }
>    root_type Items;    
>```
>
>- **把Schema编译成Java**
>
>```
>   flatc.exe -j -b Character.fbs
>```
>
>- **把生成的文件复制到项目中**

![](/Users/candice/Documents/WorkSpace/ASProjects/InterviewQuestionofAndroid/app/pics/性能优化/FlatBuffers-image3.png)

>- **编写代码**
>
>**序列化**
>
>```java
>    FlatBufferBuilder builder = new FlatBufferBuilder();
>    int car1 = Car.createCar(builder, 1000l, 8000l, builder.createString("1000的描述"));
>    int car2 = Car.createCar(builder, 1001l, 8001l, builder.createString("1001的描述"));
>    int car3 = Car.createCar(builder, 1002l, 8002l, builder.createString("1002的描述"));
>    int basic1 = Basic.createBasic(builder, 2000,
>            builder.createString("2000产品"), true,
>            Basic.createCarListVector(builder, new int[]{car1, car2, car3}));
>    int basic2 = Basic.createBasic(builder, 2001,
>            builder.createString("2001产品"), true,
>            Basic.createCarListVector(builder, new int[]{car2, car3}));
>    int itemListId = Items.createItemListVector(builder, new int[]{basic1, basic2});
>    Items.startItems(builder);
>    Items.addItemList(builder,itemListId);
>    Items.addTimestemp(builder,2017l);
>    int endItems = Items.endItems(builder);
>    Items.finishItemsBuffer(builder,endItems);
>    FileOutputStream out = null;
>    FileChannel inChannel = null;
>    try{
>        if(mSerializeFile.exists()){
>            mSerializeFile.delete();
>        }
>        out = new FileOutputStream(mSerializeFile);
>        inChannel = out.getChannel();
>        ByteBuffer buffer =
>                builder.dataBuffer();
>        while (buffer.hasRemaining()) {
>            inChannel.write(buffer);
>        }
>        Toast.makeText(this,"序列号成功",Toast.LENGTH_LONG).show();
>
>    }
>```
>
>**反序列化**
>
>```java
>        in  = new FileInputStream(mSerializeFile);
>        outChannel = in.getChannel();
>        ByteBuffer buffer = ByteBuffer.allocate(1024);
>        int readSize = 0;
>        while((readSize= outChannel.read(buffer))!=-1){
>            Log.e(TAG,"===>"+readSize);
>        }
>        buffer.flip();
>        Items rootAsItems = Items.getRootAsItems(buffer);
>        Log.e(TAG , "timestem ==>"+rootAsItems.timestemp());
>        int itemsLength
>                = rootAsItems.itemListLength();
>        for (int i = 0; i < itemsLength; i++) {
>            Basic basic = rootAsItems.itemList(i);
>            Log.e(TAG,"---id:"+basic.id()+"---name:"+basic.name());
>            int carListLength = basic.carListLength();
>            for (int i1 = 0; i1 < carListLength; i1++) {
>                Car car = basic.carList(i1);
>                Log.e(TAG,"-------------id:"+car.id()+"---describle:"+car.describle());
>            }
>        }
>        Toast.makeText(this,"序列号成功",Toast.LENGTH_LONG).show();
>    }
>```
>
>##### 2.5 使用建议
>
>1).项目中有大量数据传输和解析，使用 JSON 成为了性能瓶颈时使用FlatBuffers
>(2).稳定的数据结构定义,可以使用FlatBuffers

### 10.启动时间优化

#### (1) APP应用有几种启动方式？

>###### (1).冷启动
>
>应用从桌面上启动，且后台没有进程的缓存，这时系统就需要新创建一个进程并且分配资源。
>
>###### (2).热启动
>
>app在后台有进程缓存

#### (2) 启动方式有哪些不同

>​	对于冷启动来说，多了一个创建进程，这块也是我们优化的重点。热启动不需要重新分配进程，也不会Application了，直接走的就是app的入口Activity，这样就速度快很多.

#### (3) 启动时间消耗到哪里去了？

>​	当用户点击桌面图标开始，系统会立即为这个APP创建独立的专属进程，然后显示启动窗口，直到APP在自己的进程里面完成了程序的创建以及主线程完成了Activity的初始化显示操作，再然后系统进程就会把启动窗口替换成APP的显示窗口。
>
>**启动流程描述：**
>
>```
>创建APP进程-->显示启动窗口(displsy start window)-->Application从构造方法开始--->attachBaseContext()--->onCreate()
>Activity构造方法--->onCreate()--->设置显示界面布局，设置主题、背景等等属性
>--->[onStart()--->onResume()--->显示里面的view（测量、布局、绘制，显示到界面上）](窗口替换)
>```

![](/Users/candice/Documents/WorkSpace/ASProjects/InterviewQuestionofAndroid/app/pics/性能优化/启动时间优化-image1.png)



>流程中很多步骤是系统控制的，我们能够控制的和关注的点有以下几个：
>
>###### (1).Application的onCreate,一般应用中通用主件和初始化都放在这里(耗时主因)
>
>###### (2).Activity的onCreate，UI布局和渲染(耗时主因)
>
>###### (3).显示启动窗口到窗口替换之间，会出现白屏的过度画面，体验太差（视主题而定，必须优化）
>
>上面分析出来启动耗时的主因和启动白屏的点，这些都是我们需要解决的问题。在给出解决方案前，我们先来看下关于启动性能的评估工具有哪些？任何更好的定位问题的所在。

#### (4) 查看启动过程中时间消耗的工具

>##### 4.1 **display time**
>
>​	从Android KitKat版本开始，Logcat中会输出从程序启动到某个Activity显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。

![](/Users/candice/Documents/WorkSpace/ASProjects/InterviewQuestionofAndroid/app/pics/性能优化/启动时间优化-image2.png)

>##### 4.2 **Traceview**
>
>**代码生成trace文件**
>
>```java
>Debug.startMethodTracing("perform");
>Debug.stopMethodTracing();
>```
>
>![](/Users/candice/Documents/WorkSpace/ASProjects/InterviewQuestionofAndroid/app/pics/性能优化/启动时间优化-image3.png)
>
>- 在下方的方法区点击"Real Time/Call", 按照方法每次调用耗时降序排.
>- 耗时超过500ms都是值得注意的.
>
>##### 4.3 adb shell
>
>使用命令行来启动app，同事进行时间测量。单位：ms
>
>```
>adb shell am start -W [PackageName]/[PackageName.MainActivity]
>adb shell am start -W com.skcodestack.performanceoptimization/com.skcodestack.performanceoptimization.speed.SplashActivity
>```
>
>ThisTime: 165 指当前指定的MainActivity的启动时间
>TotalTime: 165 整个应用的启动时间，Application+Activity的使用的时间。
>WaitTime: 175 包括系统的影响时间---比较上面大。

#### (5) 建议

>##### 5.1 **Application的onCreate 中优化**
>
>​	在Application初始化的地方做太多繁重的事情是可能导致严重启动性能问题，Application里面的初始化操作不结束，其他任意的程序操作都无法进行。
>
>```java
>    @Override
>    public void onCreate() {
>        super.onCreate();
>        CrashReport.initCrashReport(getApplicationContext(), BUGLY_APP_ID, false);
>        SharedPreferences sharedPreferences =  getCacheSharedPreferences();
>        //皮肤管理初始化
>        SkinManager.getInstance().init(this);
>        //初始化
>        ToastUtils.init(this);
>        //数据库管理
>        DaoManager.init(this);
>    }
>```
>
>**方案**
>
>- 不需要立刻初始化的，延迟加载
>- 需要初始化的，开启线程初始化
>
>**延迟加载**
>
>当我们想要使用时，再初始化
>
>```java
>    static SharedPreferences mSp = null;
>    public static synchronized  SharedPreferences getAppSharedPreFerences(Context context){
>        if(mSp == null){
>            mSp = context.getApplicationContext().getSharedPreferences(NAME,MODE_PRIVATE);
>        }
>        return mSp;
>    }
>```
>
>**开启线程初始化**
>
>可以使用IntentService
>
>```java
>    public class InitIntentService extends IntentService {
>    // TODO: Rename actions, choose action names that describe tasks that this
>    // IntentService can perform, e.g. ACTION_FETCH_NEW_ITEMS
>    private static final String ACTION_FOO = "com.skcodestack.performanceoptimization.speed.action.FOO";
>    public InitIntentService() {
>        super("InitIntentService");
>    }
>    /**
>     * Starts this service to perform action Foo with the given parameters. If
>     * the service is already performing a task this action will be queued.
>     *
>     * @see IntentService
>     */
>    // TODO: Customize helper method
>    public static void startActionFoo(Context context) {
>        Intent intent = new Intent(context, InitIntentService.class);
>        intent.setAction(ACTION_FOO);
>        context.startService(intent);
>    }
>
>    @Override
>    protected void onHandleIntent(Intent intent) {
>        if (intent != null) {
>            final String action = intent.getAction();
>            if (ACTION_FOO.equals(action)) {
>                handleActionFoo();
>            } 
>        }
>    }
>
>    /**
>     * Handle action Foo in the provided background thread with the provided
>     * parameters.
>     */
>    private void handleActionFoo() {
>        //初始化 app 
>        ....        
>    }
>}
>
>    @Override
>    public void onCreate() {
>        super.onCreate();
>        InitIntentService.startActionFoo(this);
>    }
>```
>
>##### 5.2 **Activity的onCreate中优化**
>
>​	提升Activity的创建速度是优化APP启动速度的首要关注目标。从桌面点击APP图标启动应用开始，程序会显示一个启动窗口等待Activity的创建加载完毕再进行显示。在Activity的创建加载过程中，会执行很多的操作，例如设置页面的主题，初始化页面的布局，加载图片，获取网络数据，读写Preference等等。任何一个环节出现性能问题都可能导致画面不能及时显示，影响了程序的启动速度。
>
>**建议**
>
>- 优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，在渲染优化的文章中已经讲过。
>
>- 异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。
>
>- 预加载：在前一个显示时预加载下一个显示页面中需要用到的数据（常常用到Spalsh调整主页面时使用）
>
>##### 5.3 闪屏优化
>
>在应用启动时，屏幕会显示一个空白的窗口(颜色基于主题), 直至activity渲染完毕.
>
>第一种，自定义一张图片，把这张图片通过设置主题的方式显示为启动闪屏，代码执行到主页面的onCreate的时候设置为程序正常的主题。
>
>```java
><layer-list xmlns:android="http://schemas.android.com/apk/res/android">
>    <item android:drawable="@android:color/white"></item>
>    <item>
>        <bitmap android:src="@drawable/timg"
>            android:gravity="center"/>
>    </item>
></layer-list>
>
><style name="SplashTheme" parent="AppTheme">
>    <!-- Customize your theme here. -->
>    <item name="android:windowBackground">@drawable/splash_background</item>
></style>
>
>    protected void onCreate(Bundle savedInstanceState) {
>        super.onCreate(savedInstanceState);
>        setTheme(R.style.SplashTheme);  
>        startActivity(new Intent(this,SpeedMainActivity.class));
>        finish();
>    }
>```
>
>第二种，就是上面提到的预加载数据+延时加载布局，我们将Splash页面和主页面合并成一个页面，先显示Splash（尽量简单），然后等异步加载的主页数据完成（设定欢迎界面的友好时间），就显示主页面。
>
>```java
><RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
>    xmlns:tools="http://schemas.android.com/tools"
>    android:id="@+id/activity_splash_and_main"
>    android:layout_width="match_parent"
>    android:layout_height="match_parent">
>    <ViewStub
>        android:id="@+id/content_viewstub"
>        android:layout_width="match_parent"
>        android:layout_height="match_parent"
>        android:layout="@layout/activity_speed_main"
>        />
>    <FrameLayout
>        android:id="@+id/frame"
>        android:layout_width="match_parent"
>        android:layout_height="match_parent">
>    </FrameLayout>
></RelativeLayout>
>```
>
>**MainActivity**
>
>```java
>@Override
>    protected void onCreate(Bundle savedInstanceState) {
>        super.onCreate(savedInstanceState);
>        setContentView(R.layout.activity_splash_and_main);
>
>        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
>        final SplashFragment splashFragment = new SplashFragment();
>        FragmentTransaction fragmentTransaction = transaction.replace(R.id.frame, splashFragment);
>        fragmentTransaction.commit();
>
>        final ViewStub viewStub = (ViewStub) findViewById(R.id.content_viewstub);
>        //当窗体加载完毕时，执行
>        getWindow().getDecorView().post(new Runnable() {
>            @Override
>            public void run() {
>                //加载布局
>                viewStub.inflate();
>                //开始延迟加载
>                mHandler.postDelayed(new DelayRunnable(SplashAndMainActivity.this,splashFragment),2000);
>            }
>        });
>    }
>    /**
>     * 延迟操作
>     */
>    private   static  class DelayRunnable implements Runnable{
>        private WeakReference<Context> mContextRef;
>        private WeakReference<SplashFragment> mFragmentRef;
>
>        public DelayRunnable(Context context,SplashFragment fragment) {
>            this.mContextRef = new WeakReference<Context>(context);
>            this.mFragmentRef = new WeakReference<SplashFragment>(fragment);
>        }
>
>        @Override
>        public void run() {
>            if(mContextRef != null){
>                FragmentActivity activity = (FragmentActivity) mContextRef.get();
>                if(mFragmentRef != null && activity != null && mFragmentRef.get() != null){
>                    SplashFragment fragment = mFragmentRef.get();
>                    FragmentTransaction transaction = activity.getSupportFragmentManager().beginTransaction();
>                    transaction.remove(fragment);
>                    transaction.commit();
>                }   
>            }
>        }
>    }
>```

### 11. App瘦身

#### (1) 清理无用的资源

​	在我们应用版本的迭代中，肯定有废弃的代码和资源，我们要及时地清理，来减小App体积，下面给出几种清理的方法。

>##### 1.1 使用Refactor->Remove unused Resource(android studio)
>
>##### 1.2 使用Lint工具
>
>lint工具还是很有用的，它给我我们需要优化的点，这个在介绍工具的文章已经讲过，下面我只给出需要注意的点：
>
>- 检测没有用的布局并且删除
>- 把未使用到的资源删除
>- 建议String.xml有一些没有用到的字符也删除掉
>
>##### 1.3 **开启shrinkResources去除无用资源**
>
>​	在build.gradle 里面配置shrinkResources true，在打包的时候会自动清除掉无用的资源，但经过实验发现打出的包并不会，而是会把部分无用资源用更小的东西代替掉。注意，这里的“无用”是指调用图片的所有父级函数最终是废弃代码，而shrinkResources true 只能去除没有任何父函数调用的情况.
>
>```
>    android {
>        buildTypes {
>            release {
>                shrinkResources true
>            }
>        }
>    }
>```
>
>##### 1.4 **删除无用的语言资源**
>
>大部分应用其实并不需要支持几十种语言的国际化支持。比如我们只是保存中文支持：
>
>```
>    android {
>        defaultConfig {
>            resConfigs "zh"
>        }
>    }
>```
>
>##### 1.5 **清理第三方库中冗余代码**
>
>对于第三方库，可能我们只是用到库中的一个功能，那么我们就可以导入源码，并且删除无关的代码，来减小体积。

#### (2) 图片资源优化

>图片是占用空间比较大的资源，这是我们要重点优化的地方。
>
>###### (1).使用压缩过的图片
>
>这个在前面关于图片压缩已经讲过，这里就不再累赘。
>
>###### (2).只用一套图片
>
>对于绝大对数APP来说，只需要取一套设计图就足够了。从内存占用和适配的角度考虑，这一套图建议放在xhdpi文件夹下；
>
>###### (3).使用不带alpha值的jpg图片
>
>对于非透明的大图，jpg将会比png的大小有显著的优势，虽然不是绝对的，但是通常会减小到一半都不止。
>
>###### (4).使用tinypng有损压缩
>
>支持上传PNG图片到官网上压缩，然后下载保存，在保持alpha通道的情况下对PNG的压缩可以达到1/3之内，而且用肉眼基本上分辨不出压缩的损失.
>
>###### (5).使用webp格式
>
>webp支持透明度，压缩比比jpg更高但显示效果却不输于jpg,从Android 4.0+开始原生支持，但是不支持包含透明度，直到Android 4.2.1+才支持显示含透明度的webp，使用的时候要特别注意。
>
>###### (6).使用svg
>
>矢量图是由点与线组成,和位图不一样,它再放大也能保持清晰度，而且使用矢量图比位图设计方案能节约30～40%的空间，现在谷歌一直在强调扁平化方式，矢量图可很好的契合该设计理念。
>
>- 占用存储空间小
>- 无极拉伸不会出现锯齿，可以照顾不同尺寸的机型
>- Android Studio自带很多资源
>
>###### (7).使用shape
>
>特别是在扁平化盛行的当下，很多纯色的渐变的圆角的图片都可以用shape实现，代码灵活可控，省去了大量的背景图片。
>
>###### (8).使用着色方案
>
>相信你的工程里也有很多selector文件，也有很多相似的图片只是颜色不同，通过着色方案我们能大大减轻这样的工作量，减少这样的文件。
>
>###### (9).对打包后的图片进行压缩
>
>使用7zip压缩方式对图片进行压缩,建议使用微信的[AndResGuard](https://github.com/shwenzhang/AndResGuard)

#### (3) 资源动态加载

>资源可以动态加载，减小apk体积。
>
>###### (1).在线化素材库
>
>如果你的APP支持素材库(比如聊天表情库)的话，考虑在线加载模式，因为往往素材库都有不小的体积
>
>###### (2).皮肤加载
>
>有的app用到皮肤库，这是就可以使用动态加载。
>
>###### (3).模块插件化
>
>如果模块过大，apk体积过大，可以考虑插件化，来减少体积。

#### (4) lib库优化

​	只提供对主流架构的支持，比如arm，对于mips和x86架构可以考虑不支持，这样可以大大减小APK的体积.

#### (5) 7zip压缩资源

​	对于assets或者raw文件夹中的资源，可以使用7zip压缩，使用时进行解压。

#### (6) 代码混淆

​	在gradle使用minifyEnabled进行Proguard混淆的配置.

```java
    android {
        buildTypes {
            release {
                minifyEnabled true
            }
        }
    }
```

>###### 为什么代码混淆可以让apk变小?
>
>1）可以删除注释和不用的代码。
>2）将java文件名改成短名
>3）将方法名改成短名

#### (7) **资源(res)混淆**

​	资源混淆简单来说希望实现将res/drawable/icon,png变成res/drawable/a.png,或我们甚至可以将文件路径也同时混淆，改成r/s/a.png。
建议使用微信的[AndResGuard](https://github.com/shwenzhang/AndResGuard)

#### (8) **使用微信AndResGuard**

使用微信AndResGuard对资源混淆并且压缩图片res等资源

```groovy
   apply plugin: 'AndResGuard'
    buildscript {
        dependencies {
            classpath 'com.tencent.mm:AndResGuard-gradle-plugin:1.1.7'
        }
    }
    andResGuard {
        mappingFile = null
        use7zip = true
        useSign = true
        keepRoot = false
        // add <your_application_id>.R.drawable.icon into whitelist.
        // because the launcher will get thgge icon with his name
        def packageName = <your_application_id>
                whiteList = [
        //for your icon
        packageName + ".R.drawable.icon",
                //for fabric
                packageName + ".R.string.com.crashlytics.*",
                //for umeng update
                packageName + ".R.string.umeng*",
                packageName + ".R.string.UM*",
                packageName + ".R.string.tb_*",
                packageName + ".R.layout.umeng*",
                packageName + ".R.layout.tb_*",
                packageName + ".R.drawable.umeng*",
                packageName + ".R.drawable.tb_*",
                packageName + ".R.anim.umeng*",
                packageName + ".R.color.umeng*",
                packageName + ".R.color.tb_*",
                packageName + ".R.style.*UM*",
                packageName + ".R.style.umeng*",
                packageName + ".R.id.umeng*"
        ]
        compressFilePattern = [
        "*.png",
                "*.jpg",
                "*.jpeg",
                "*.gif",
                "resources.arsc"
        ]
        sevenzip {
            artifact = 'com.tencent.mm:SevenZip:1.1.7'
            //path = "/usr/local/bin/7za"
        }
    }
```

#### (9) **Facebook的redex优化字节码**

redex是facebook发布的一款android字节码的优化工具.
[redex](https://github.com/facebook/redex)

### 12.服务优化

两个方面：服务保活；服务后台对于执行任务的集中处理

###### 开始先来说下我们实现的方式：

1.提高进程优先级

2.java层双进程守护

3.1个像素的Activity保活

4.JobScheduler轮询

5.native层双进程守护

#### (1) 进程的优先级

>##### 1.1 前台进程
>
>- Activity已调用onResume()方法
>- Service服务已调用startForeground()
>- 生命周期回调的Service (onCreate() 、onStart()或onDestroy())
>- 正执行其onReceive()方法的BroadcastReceiver
>
>##### 1.2 可见进程
>
>- 不在前台、但仍对用户可见的Activity（比如调用其onPause()方法）
>- 绑定到可见（或前台）Activity 的Service
>
>##### 1.3 服务进程
>
>- startService()方法启动的服务，且不属于上面两类
>
>##### 1.4 后台进程
>
>- 对用户不可见的 Activity 的进程已调用 Activity 的onStop()方法
>
>##### 1.5 空进程
>
>- 不含任何活动应用组件的进程

#### (2) 何时进程被杀死

>##### 2.1 应用内存不足，回收进程
>
>​	提高进程优先级，减少进程oom_adj值，如启动进程的setForeground()提高进程优先级
>
>​	当应用程序退到后台时，释放占用的资源，因为当oom_adj相同时，优先释放内存消耗大的进程
>
>​	一直在后台运行的进程一定要轻
>
>##### 2.2 系统第三方清理软件，杀死进程
>
>​	使用aidl，实现双进程守护
>​	白名单
>
>##### 2.3 各大rom昌盛在应用退出时，会清理杀死进程
>
>​	使用NDK，轮询查看指定进程是否被杀死，如果杀死fork进程，启动
>​	使用JobScheduler，轮询查看指定进程是否被杀死，如果杀死，启动

### (3) 双进程守护

>##### 3.1 编写aidl接口
>
>```
>   interface ProcessConnect {
>
>    }
>```
>
>接口里面什么都没有，这个只是用来监听是否断开连接，如果断开，就代码启动服务。
>
>##### 3.2 工作服务
>
>```java
>public class MessageService extends Service {
>
>    private String TAG = "MessageService";
>
>    private int ID=0X00022;
>    private static Context mContext;
>
>    @Override
>    public void onCreate() {
>        super.onCreate();
>        mContext = this;
>
>        new Thread(new Runnable() {
>            @Override
>            public void run() {
>                while (true) {
>                    Log.e(TAG, "MessageService====>print");
>
>                    try {
>                        Thread.sleep(5000);
>                    } catch (InterruptedException e) {
>                        e.printStackTrace();
>                    }
>                }
>            }
>        }).start();
>
>    }
>
>    @Override
>    public int onStartCommand(Intent intent, int flags, int startId) {
>        //assert uri
>        String path = "file:///android_asset/xiaoxin.wav";
>        Notification.Builder builder = new Notification.Builder(mContext);
>        Notification notification = builder
>                .setContentText("messageservice")
>                .setSmallIcon(R.drawable.ting)
>                .setSound(Uri.parse(path))
>                .build();
>
>        startForeground(ID,notification);
>
>
>        bindService(new Intent(MessageService.this,GuardService.class),mServiceConnection,BIND_WAIVE_PRIORITY);
>
>        return START_STICKY;
>    }
>    public ServiceConnection  mServiceConnection = new ServiceConnection() {
>
>        @Override
>        public void onServiceConnected(ComponentName name, IBinder service) {
>            Log.e(TAG, "MessageService====>onServiceConnected");
>        }
>
>        @Override
>        public void onServiceDisconnected(ComponentName name) {
>
>            startService(new Intent(MessageService.this,GuardService.class));
>            bindService(new Intent(MessageService.this,GuardService.class),mServiceConnection,BIND_WAIVE_PRIORITY);
>        }
>    };
>
>    @Nullable
>    @Override
>    public IBinder onBind(Intent intent) {
>        return new ProcessConnect.Stub() {
>
>        };
>    }
>}
>```
>
>##### 3.3 守护服务
>
>```java
>    public class GuardService extends Service {
>        private Context mContext;
>        private int ID=0X00021;
>        @Override
>        public void onCreate() {
>            super.onCreate();
>            mContext = this;
>    
>        }
>    
>            @Override
>        public int onStartCommand(Intent intent, int flags, int startId) {
>                //assert uri
>                String path = "file:///android_asset/xiaoxin.wav";
>                Notification.Builder builder = new Notification.Builder(mContext);
>                Notification notification = builder
>                        .setContentText("GuardService")
>                        .setSmallIcon(R.drawable.ting)
>                        .setSound(Uri.parse(path))
>                        .build();
>    
>                startForeground(ID,notification);
>    
>                bindService(new Intent(GuardService.this,MessageService.class),mServiceConnection,BIND_WAIVE_PRIORITY);
>    
>                return START_STICKY;
>        }
>    
>        @Nullable
>        @Override
>        public IBinder onBind(Intent intent) {
>            return new ProcessConnect.Stub(){
>    
>            };
>        }
>    
>        public ServiceConnection  mServiceConnection = new ServiceConnection() {
>    
>            @Override
>            public void onServiceConnected(ComponentName name, IBinder service) {
>                Log.e("GuardService", "GuardService====>onServiceConnected");
>            }
>    
>            @Override
>            public void onServiceDisconnected(ComponentName name) {
>    
>                startService(new Intent(GuardService.this,MessageService.class));
>                bindService(new Intent(GuardService.this,MessageService.class),mServiceConnection,BIND_WAIVE_PRIORITY);
>            }
>        };
>    
>    }
>```
>
>从上面两个服务可以看到，每当一个服务结束，另一个服务就会启动它，来实现进程不被关闭。
>
>##### 3.4 **MainActivity开启服务**
>
>```java
> startService(new Intent(this,MessageService.class));
> startService(new Intent(this,GuardService.class));
>```
>
>##### 3.5 配置
>
>```java
><service android:name=".MessageService"></service>
>    //新的进程中运行
>    <service android:name=".GuardService" android:process=":guardservice"></service>
>```
>
>​	主要五步就搞定了，很简单吧，但是不要高兴的太早，因为这种双进程守护的方法，只能对4.0以下有效，对于4.0以上机型，只能部分有用，这个问题最后再说，我们先来看下使用JobScheduler，轮询启动被杀死的进程。

#### (4) 1个像素的Activity保活

>​	启动一个1个像素的Activity，当用户解锁以后将这个Activity结束掉（顺便同时把自己的核心服务再开启一次）。被用户发现了就不好了。
>重点就是对屏幕进行监听，下面我们来分析代码：
>
>1个像素的Activity实现：
>
>```java
>    Window window = getWindow();
>    window.setGravity(Gravity.LEFT|Gravity.TOP);
>    LayoutParams params = window.getAttributes();
>    params.height = 1;
>    params.width = 1;
>    params.x = 0;
>    params.y = 0;
>    window.setAttributes(params);
>```
>
>对屏幕进行监听
>
>```java
>    private void registerListener() {
>        IntentFilter filter = new IntentFilter();
>        filter.addAction(Intent.ACTION_SCREEN_ON);
>        filter.addAction(Intent.ACTION_SCREEN_OFF);
>        filter.addAction(Intent.ACTION_USER_PRESENT);
>        mContext.registerReceiver(mScreenReceiver, filter);
>    }
>```

#### (5) JobScheduler

>在android开发中，会存在这么些场景 : 你需要在稍后的某个时间点或者当满足某个特定的条件时执行一个任务，例如当设备接通电源适配器或者连接到WIFI。幸运的是在API 21 ( Android 5.0，即Lollipop )中，google提供了一个新叫做JobScheduler API的组件来处理这样的场景。
>
>当一系列预置的条件被满足时，JobScheduler API为你的应用执行一个操作。与AlarmManager不同的是这个执行时间是不确定的。除此之外，JobScheduler API允许同时执行多个任务。这允许你的应用执行某些指定的任务时不需要考虑时机控制引起的电池消耗。
>
>下面我们就使用JobScheduler来启动我们被杀死的服务：
>
>```java
>@TargetApi(Build.VERSION_CODES.LOLLIPOP)
>public class JobWakeUpService extends JobService {
>
>    private JobScheduler service;
>    private int JobId=100;
>    @Override
>    public int onStartCommand(Intent intent, int flags, int startId) {
>        JobInfo info = new JobInfo.Builder(JobId,new ComponentName(this,JobWakeUpService.class))
>                .setPeriodic(2000)
>                .build();
>
>        service = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);
>
>        service.schedule(info);
>        return START_STICKY;
>    }
>
>    @Override
>    public boolean onStartJob(JobParameters params) {
>        Log.e("JobWakeUpService", "JobWakeUpService====>print");
>        //开始定时任务
>        if(!isServiceWork(this,MessageService.class.getName())){
>            //
>            startService(new Intent(this,MessageService.class));
>        }
>
>        return false;
>    }
>
>    @Override
>    public boolean onStopJob(JobParameters params) {
>        //停止
>        service.cancel(JobId);
>//        service.cancelAll();
>        return false;
>    }
>
>    private boolean isServiceWork(Context context,String serviceName){
>        ActivityManager am= (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
>        List<ActivityManager.RunningServiceInfo> runningServices = am.getRunningServices(100);
>        if(runningServices == null){
>            return false;
>        }
>        for (ActivityManager.RunningServiceInfo service : runningServices) {
>            String className = service.service.getClassName();
>            if(className.equals(serviceName)){
>                return true;
>            }
>        }
>        return false;
>
>    }
>}
>```
>
>我们看到这边就是使用JobScheduler服务来进行循环调用我们的JobWakeUpService的onStartJob。
>
>我们接下来看下配置：
>
>```java
>    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"></uses-permission>
>
>    <service android:name=".JobWakeUpService"
>        android:enabled="true"
>        android:permission="android.permission.BIND_JOB_SERVICE"
>        ></service>
>```
>
>调用：
>
>```java
>    if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
>        startService(new Intent(this, JobWakeUpService.class));
>    }
>```
>
>这个就能实现轮询查看指定进程是否被杀死，如果杀死，启动的功能。
>
>可能你们想问这种方式是否可以解决5.0以上进程不被杀死吗？我只能遗憾的告诉你，不能，我在华为7.0上的测试，没有能够起来。
>
>我们看了这么多的方式，也不能解决进程不被杀死的情况，那有没有更好的办法呢？

