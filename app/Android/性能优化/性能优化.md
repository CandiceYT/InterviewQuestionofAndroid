[TOC]



### 1.内存泄漏

#### (1) 何为内存泄漏

> 当一个对象已经不需要在使用了，本应该被回收，而另一个正在使用的对象持有它的引用，导致对象不能被回收。因为不能被及时回收的本该被回收的内存，就产生了内存泄漏。如果内存泄漏太多会导致程序没有办法申请内存，最后出现内存溢出的错误。

#### (2) 常见内存泄漏场景

> - 使用单例模式
> - 使用匿名内部类
> - 使用异步事件处理机制Handler
> - 使用静态变量
> - 资源未关闭
> - 设置监听
> - 使用AsyncTask
> - 使用Bitmap

#### (3) Java虚拟机内存管理

![](/Users/candice/Documents/笔记/Android/内存优化/Java虚拟机内存管理.png)

> ###### (1).虚拟机栈
>
> - 虚拟机栈主要的作用就是为执行java方法服务的，是Java方法执行的动态内存模型。
>
> ###### * 会导致栈内存溢出(StackOverFlowError)
>
> ###### (2).本地方法栈
>
> - 为执行native方法服务的，其他和虚拟机栈一样
>
> ###### (3).程序计数器
>
> - 是当前线程执行的字节码行号指示器
> - 处于线程独占区
> - 如果是执行的是java代码,当前值为字节码指令的地址，如果是Native，值为undefined
>
> ###### (4).堆
>
> - 存放对象的实例
> - 垃圾收集器管理的主要区域
> - 分代管理对象
> - 会导致内存溢出(OutOfMemoryError)
>
> ###### (5).方法区
>
>  - 存放虚拟机加载的类信息，常量，静态变量，编译后的代码和数据
>  - GC主要对方法区进行常量回收和类卸载
>  - 会出现内存溢出(OutOfMemoryError)
>

#### (4) Java内存几种分配策略

> ##### (1).静态的
>
> - 静态存储区：内存在程序编译期间就已经分配完成，一般来说，这个区域在程序运行期间一直处在
> - 它主要储存静态数据，全局静态数据和常量
>
> ##### (2).栈式的
>
> - 执行方法时，存储局部变量(编译期间，已经确定占用内存大小)，操作数，动态链接，方法出口
>
> ##### (3).堆式的
>
> - 也叫动态内存分配，主要存储对象实例，以及已经被加载类的Class对象(用于反射)

#### (5) 垃圾收集器是如何判断对象是否可回收

> *** 引用计数**(早期的主要用，native使用)
>
> 对象被引用，引用计数器加1，反之减一，只有引用计数为0,那么这个对象为垃圾对象
>
> *** 可达性**(现在大部分使用)
>
> 从GCRoot节点对象开始，看是否可以访问到此对象，如果没有访问到则为垃圾对象
>
> **可以作为GCRoot对象有以下几种：**
>
> - 虚拟机栈中的局部变量
> - 本地方法栈中的引用对象
> - 方法区中的常量引用对象
> - 方法区中的类属性引用对象

#### (6) 内存抖动

> 堆内存都有一定的大小，能容纳的数据是有限制的，当Java堆的大小太大时，垃圾收集会启动停止堆中不再应用的对象，来释放内存。当在极短时间内分配给对象和回收对象的过程就是内存抖动。

#### (7) 内存抖动产生的原因？

> 从术语上来讲就是极短时间内分配给对象和回收对象的过程。
>  一般多是在循环语句中创建临时对象，在绘制时配置大量对象或者执行动画时创建大量临时对象
>  内存抖动会带来UI的卡顿，因为大量的对象创建，会很快消耗剩余内存，导致GC回收，GC会占用大量的帧绘制时间，从而导致UI卡顿，关于UI卡顿会在后面章节讲到。

#### (8) Android中4种引用

> ###### (1).StrongReference强引用
>
> 从不被回收，java虚拟机停止时，才终止
>
> ###### (2).SoftReference软引用
>
> 当内存不足时，会主动回收，使用SoftReference使用结合ReferenceQueue构造有效期短
>
> ###### (3).WeakReference弱引用
>
> 每次垃圾回收时，被回收
>
> ###### (4).PhatomReference虚引用
>
> 每次垃圾回收时，被回收.结合ReferenceQueue来跟踪对象被垃圾回收器回收的活动

#### (9) 常见内存泄漏场景

> ##### (1).使用单例模式、**使用静态变量**

```java
  private static ComonUtil mInstance = null;
    private Context mContext = null;

    public ComonUtil(Context context) {
        mContext = context;
    }

    public static ComonUtil getInstance(Context context) {
        if (mInstance == null) {
            mInstance = new ComonUtil(context);
        }
        return mInstance;
    }
//使用
  ComonUtil mComonUtil = ComonUtil.getInstance(this);
```

> 我们看到上面的代码就是我们平时使用的单例模式，当然这里没有考虑线程安全，请忽略。当我们传递进来的是Context，那么当前对象就会持有第一次实例化的Context，如果Context是Activity对象，那么就会产生内存泄漏。因为当前对象ComonUtil是静态的，生命周期和应用是一样的，只有应用退出才会释放，导致Activity不能及时释放，带来内存泄漏。
>
> ###### 怎么解决呢？
>
> 常见的有两种方式，第一就是传入ApplicationContext，第二CommonUtil中取context.getApplicationContext()。

> ##### (2).使用非静态内部类

```java
/**
     * 非静态内部类
     */
    public void createNonStaticInnerClass(){
        CustomThread mCustomThread = new CustomThread();
        mCustomThread.start();
    }

    public class CustomThread extends Thread{
        @Override
        public void run() {
            super.run();
            while (true){
                try {
                    Thread.sleep(5000);
                    Log.i(TAG,"CustomThread ------- 打印");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

```

> 我们就以线程为例，当Activity调用了createNonStaticInnerClass方法，然后退出当前Activity时，因为线程还在后台执行且当前线程持有Activity引用，只有等到线程执行完毕，Activitiy才能得到释放，导致内存泄漏。
>  常用的解决方法有很多，第一把线程类声明为静态的类，如果要用到Activity对象，那么就作为参数传入且为WeakReference,第二在Activity的onDestroy时，停止线程的执行。

```java
  public static class CustomThread extends Thread{
        private WeakReference<MainActivity> mActivity;
        public CustomThread(MainActivity activity){
            mActivity = new WeakReference<MainActivity>(activity)
        }
    }
```

> ##### (3).**使用异步事件处理机制Handler**

```java
 /**
     * 异步消息处理机制  -- handler机制
     */
    public void createHandler(){
        mHandler.sendEmptyMessage(0);
    }
    public Handler mHandler = new Handler(new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            //处理耗时操作   
            return false;
        }
    });
```

> 这个应该是我们平时使用最多的一种方式，如果当handler中处理的是耗时操作，或者当前消息队列中消息很多时，那当Activity退出时，当前message中持有handler的引用，handler又持有Activity的引用，导致Activity不能及时的释放，引起内存泄漏的问题。
>  解决handler引起的内存泄漏问题常用的两种方式：
>  1.和上面解决Thread的方式一样，
>  2.在onDestroy中调用mHandler.removeCallbacksAndMessages(null)

```java
  @Override
    protected void onDestroy() {
        super.onDestroy();
        mHandler.removeCallbacksAndMessages(null);
    }
```

> ##### (4).资源未关闭
>
> - 数据库游标未关闭
> - 对象文件流未关闭
> - 注册/解注册未成对出现 

> ##### (5).设置监听
>
> 常见的是在观察者模式中出现，我们在退出Acviity时没有取消监听，导致被观察者还持有当前Activity的引用，从而引起内存泄漏。
> 常见的解决方法就是在onPause中注消监听

> ##### (6).**使用AsyncTask**

```java
public AsyncTask<Object, Object, Object> mTask = new AsyncTask<Object, Object, Object>() {

        @Override
        protected Object doInBackground(Object... params) {
            //耗时操作
            return null;
        }

        @Override
        protected void onPostExecute(Object o) {
        
        }   
    };
```

> 和上面同样的道理，匿名内部类持有外部类的引用，AsyncTask耗时操作导致Activity不能及时释放，引起内存泄漏。
> 解决方法同上:
> 1.声明为静态类，
> 2.在onPause中取消任务

> ##### (7).**使用Bitmap**
>
> 我们知道当bitmap对象没有被使用(引用)，gc会回收bitmap的占用内存，当时这边的内存指的是java层的，那么本地内存的释放呢？我们可以通过调用bitmap.recycle()来释放C层上的内存，防止本地内存泄漏

分析工具：Android profiler

### 2.UI渲染优化

#### (1) ANR

>##### (1).什么是ANR?
>
>ANR全名Application Not Responding, 也就是"应用无响应".当操作在一段时间内系统无法处理时, 系统层面会弹出ANR对话框.
>
>##### (2).产生的原因
>
>APP的响应是Activity Manage和Window Manage来监控的，系统产生ANR的原因：
>
>- Activity5s内无法响应用户输入事件
>- BoradCastReceiver在10s内没有处理结束
>	上面两点的根本原因就是主线程有耗时操作。
>- Service在20s内没有处理
>
>##### (3).如何避免
>
>1. 耗时操作放到子线程操作
>2. I/O操作放到子线程
>3. 避免内存泄漏（内存不够也会造成ANR，当时大多数情况是OOM）
>
>##### (4).ANR如何分析？
>
>导出/data/anr/下的traces.txt,发现日志来定位问题
>
>```java
>adb pull data/anr/traces.txt ./
>```

#### (2) 怎么衡量渲染性能的好坏?

>##### (1).16ms
>
>要知道Android系统每隔16ms就发出VSYNC信号重新绘制一次Activity,所以要在16ms内能够完成绘制，这样才能达到每秒60帧，然而这个每秒帧数的参数由手机硬件所决定，现在大多数手机屏幕刷新率是60赫兹（赫兹是国际单位制中频率的单位，它是每秒中的周期性变动重复次数的计量），也就是说我们有16ms（1000ms/60次=16.66ms）的时间去完成每帧的绘制逻辑操作，就不会出现卡顿的现象，如果没有完成，则会丢帧导致卡顿。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image1.png)
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image2.png)

#### (3) 关于渲染管线

> Android系统的渲染管线分为两个关键组件：CPU和GPU，它们共同工作，在屏幕上绘制图片，每个组件都有自身定义的特定流程。我们必须遵守这些特定的操作规则才能达到效果。

![](/Users/candice/Documents/笔记/Android/内存优化/UI image3.png)

> CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。
>  在CPU方面，最常见的性能问题是不必要的布局和失效，这些内容必须在视图层次结构中进行测量、清除并重新创建，引发这种问题通常有两个原因：一是重建显示列表的次数太多，二是花费太多时间作废视图层次并进行不必要的重绘，这两个原因在更新显示列表或者其他缓存GPU资源时导致CPU工作过度。
>  在GPU方面，最常见的问题是我们所说的过度绘制（overdraw），通常是在像素着色过程中，通过其他工具进行后期着色时浪费了GPU处理时间。
>
> ##### (1).GPU
>
> ![](/Users/candice/Documents/笔记/Android/内存优化/UI image4.png)

> Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。

![](/Users/candice/Documents/笔记/Android/内存优化/UI image5.png)

> GPU使用一些指定的基础指令集，主要是多边形和纹理，也就是图片，CPU在屏幕上绘制图像前会向GPU输入这些指令，这一过程通常使用的API就是Android的OpenGL ES，这就是说，在屏幕上绘制UI对象时无论是按钮、路径或者复选框，都需要在CPU中首先转换为多边形或者纹理，然后再传递给GPU进行格栅化。
>  UI对象转换为一系列多边形和纹理的过程肯定相当耗时，从CPU上传处理数据到GPU同样也很耗时。所以很明显，我们需要尽量减少对象转换的次数，以及上传数据的次数，幸亏，OpenGL ES API允许数据上传到GPU后可以对数据进行保存，当我们下次绘制一个按钮时，只需要在GPU存储器里引用它，然后告诉OpenGL如何绘制就可以了，一条经验之谈：
>
> ###### 渲染性能的优化就是尽可能地上传数据到GPU，然后尽可能长地在不修改的情况下保存数据，因为每次上传资源到GPU时，我们都会浪费宝贵的处理时间.
>
> 为了能够使得App流畅，我们需要在每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作。

#### (4) 分析及解决方案

>##### (1). CPU
>
>上面已经分析过了，CPU常见的性能问题是不必要的布局和失效，引发这种问题通常有两个原因：一是重建显示列表的次数太多，二是花费太多时间作废视图层次并进行不必要的重绘。
>
>**布局失效优化**
>
>Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息,还有执行绘制操作的OpenGL命令列表。在某个View第一次需要被渲染时，Display List会因此被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。
>
>那么第二次渲染这个view会发生什么呢？
>
>**1.如果View的Property属性发生了改变（例如移动位置），我们就仅仅需要Execute Display List就够了.**

![](/Users/candice/Documents/笔记/Android/内存优化/UI image6.png)

> **2.如果你修改了View中的某些可见组件的内容，那么之前的DisplayList就无法继续使用了，我们需要重新创建一个DisplayList并重新执行渲染指令更新到屏幕上。任何时候View中的绘制内容发生变化时，都会需要重新创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。**

![](/Users/candice/Documents/笔记/Android/内存优化/UI image7.png)

> **3.如果某个View的大小需要增大到目前的两倍，在增大View大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。**

![](/Users/candice/Documents/笔记/Android/内存优化/UI image8.png)

> **嵌套结构优化**
>
> 提升布局性能的关键点是尽量保持布局层级的扁平化，避免出现重复的嵌套布局。
> 我们先来看下列子，然后再来总结：
> 当前页面有两个条目，上面条目是使用LinearLayout中嵌套LinearLayout实现的，下面条目使用一个RelativeLayout实现

![](/Users/candice/Documents/笔记/Android/内存优化/UI image9.png)

> ##### (2). 优化建议
>
> - ###### 没有用的父布局时指没有背景绘制或者没有大小限制的父布局，这样的布局不会对UI效果产生任何影响。我们可以把没有用的父布局，通过<merge/>标签合并来减少UI的层次
>
> - ###### 使用线性布局LinearLayout排版导致UI层次变深，如果有这类问题，我们就使用相对布局RelativeLayout代替LinearLayout,减少UI的层次
>
> - ###### 不常用的UI被设置成GONE,比如异常的错误页面，如果有这类问题，我们需要用<ViewStub/>标签，代替GONE提高UI性能
>
> ##### (3).常用优化示例
>
> - ######  include 标签
>
> 	include标签常用于将布局中的公共部分提取出来供其他layout共用，以实现布局模块化，这在布局编写方便提供了大大的便利。
>
> - ###### viewstub 标签
>
> 	viewstub标签同include标签一样可以用来引入一个外部布局，不同的是，viewstub引入的布局默认不会扩张，即既不会占用显示也不会占用位置，从而在解析layout时节省cpu和内存。
> 	 viewstub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等。
>
> 	ViewStub所加载的布局是不可以使用<merge>标签的
>
> ```java
>    //第一种
>     ViewStub stub = (ViewStub)findViewById(...)
>     View stubView=  stub.inflate();
>     //根据实际情况，显示
>     stubView.setVisibility()
> 
>     //第二种
>     View viewStub = findViewById(R.id.network_error_layout);
>     viewStub.setVisibility(View.VISIBLE);   // ViewStub被展开后的布局所替换
> ```
>
> -  **merge 标签**
>
> 在使用了include后可能导致布局嵌套过多，多余不必要的layout节点，从而导致解析变慢
>
> ###### merge标签可用于两种典型情况：
>
> (1). 布局顶结点是FrameLayout且不需要设置background或padding等属性，可以用merge代替，因为Activity内容试图的parent view就是个FrameLayout，所以可以用merge消除只剩一个。
>  (2). 某布局作为子布局被其他布局include时，使用merge当作该布局的顶节点，这样在被引入时顶结点会自动被忽略，而将其子节点全部合并到主布局中。

>##### (3).GPU
>
>在GPU方面，最常见的问题是我们所说的过度绘制（overdraw），通常是在像素着色过程中，通过其他工具进行后期着色时浪费了GPU处理时间。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image10.png)
>
>

> 过度绘制描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区域被绘制了多次。这样就会浪费大量的CPU以及GPU资源。
>  当设计上追求更华丽的视觉效果的时候，我们就容易陷入采用复杂的多层次重叠视图来实现这种视觉效果的怪圈。这很容易导致大量的性能问题，为了获得最佳的性能，我们必须尽量减少Overdraw的情况发生。
>
> 幸运的是，我们可以通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，观察UI上的Overdraw情况。
>
> ![](/Users/candice/Documents/笔记/Android/内存优化/UI image11.png)

>###### GPU Profiling
>
>从Android M系统开始，系统更新了GPU Profiling的工具来帮助我们定位UI的渲染性能问题。早期的CPU Profiling工具只能粗略的显示出Process，Execute，Update三大步骤的时间耗费情况。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image12.png)
>
>但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在Android M版本开始，GPU Profiling工具把渲染操作拆解成如下8个详细的步骤进行显示。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image14.png)

>旧版本中提到的Proces，Execute，Update还是继续得到了保留，他们的对应关系如下：
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image15.png)

>- Sync & Upload：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。
>- Measure & Layout：这里表示的是布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。
>- Animation：表示的是计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。
>- Input Handling：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。
>- Misc/Vsync Delay：如果稍加注意，我们可以在开发应用的Log日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况。
>
>上面八种不同的颜色区分了不同的操作所耗费的时间，为了便于我们迅速找出那些有问题的步骤，GPU Profiling工具会显示16ms的阈值线，这样就很容易找出那些不合理的性能问题，再仔细看对应具体哪个步骤相对来说耗费时间比例更大，结合上面介绍的细化步骤，从而快速定位问题，修复问题。
>
>##### (4).优化建议
>
>- **移除Window默认的Background**
>
>- ###### 移除XML布局文件中非必需的Background
>
>- **按需显示占位背景图片**
>
>	在给ImageView设置图片时，判断是否获取到对应的Bitmap，在获取到图像之后，把ImageView的Background设置为Transparent，只有当图像没有获取到的时候才设置对应的Background占位图片，这样可以避免因为设置背景图而导致的过度渲染。
>
>- **剪辑不显示的UI组件**
>
>	对不可见的UI组件进行绘制更新会导致Overdraw。例如Nav Drawer从前置可见的Activity滑出之后，如果还继续绘制那些在Nav Drawer里面不可见的UI组件，这就导致了Overdraw。为了解决这个问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少Overdraw。那些Nav Drawer里面不可见的View就不会被执行浪费资源。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image16.png)
>
>但是不幸的是，对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。
> 除了clipRect方法之外，我们还可以使用canvas.quickreject()来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。
> 下面我们来看个实例：
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image17.png)

>```java
>@Override
>protected void onDraw(Canvas canvas) {
>      super.onDraw(canvas);
>      if (mCardList != null && mCardList.size() > 0) {
>           for (int i = 0; i < mCardList.size(); i++) {
>              mCardLeft = i * mCardSpacing;
>              drawCard(canvas, mCardList.get(i), mCardLeft, 0);
>          }
>      }
>}
>
>private void drawCard(Canvas canvas, CardItem card, int left, int top) {
>        Bitmap mBitmap = getBitmap(card.resId);
>        canvas.drawBitmap(mBitmap, left, top, mPaint);
>    }
>
>private Bitmap getBitmap(int resId) {
>  return BitmapFactory.decodeResource(this.getResources(), resId);
>}
>```
>
>我们看到扑克牌有不可见的区域但是还是被绘制了，导致过度绘制。下面我们进行剪辑。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image18.png)
>
>```java
>    @Override
>    protected void onDraw(Canvas canvas) {
>        super.onDraw(canvas);
>        if (mCardList != null && mCardList.size() > 0) {
>            for (int i = 0; i < mCardList.size()-1; i++) {
>                mCardLeft = i * mCardSpacing;
>                canvas.save();
>                canvas.clipRect(mCardLeft,
>                        0f,
>                        mCardLeft + mCardSpacing,
>                        mCardList.get(i).getHeight());
>                drawCard(canvas, mCardList.get(i), mCardLeft, 0);
>                canvas.restore();
>            }
>            drawCard(canvas, mCardList.get(mCardList.size()-1), mCardLeft + mCardSpacing, 0);
>        }
>    }
>```
>
>**有些过度绘制对于运行性能，可能是必要的也是可以接受的，比如说Android的ActionBar，但是，如果我们希望应用体验更进一步，我们可以考虑尽可能地减少过度绘制。**
>
>##### (5).其他问题引起的卡粉分析
>
>**内存抖动**
>
>内存抖动是因为在短时间内大量的对象被创建又马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，会触发GC从而导致刚产生的对象又很快被回收。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题(卡顿)。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/UI image19.png)

> 解决上面的问题有简洁直观方法，如果你在Memory Monitor里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。
>
> ![](/Users/candice/Documents/笔记/Android/内存优化/UI image20.png)

> 同时我们还可以通过Allocation Tracker来查看在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一。
>
> 当你大致定位问题之后，接下去的问题修复也就显得相对直接简单了。例如，你需要避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外，自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。
>
> 工具 DDMS  Allocation Tracker  layoutinspector  **Traceview**   **Systrace**

### 3.计算性能优化

​	Android中的Java代码会需要经过编译优化再执行的过程。代码的不同写法会影响到Java编译器的优化效率。例如for循环的不同写法就会对编译器优化这段代码产生不同的效率，当程序中包含大量这种可优化的代码的时候，运算性能就会出现问题。想要知道如何优化代码的运算性能就需要知道代码在硬件层的执行差异。

#### (1) 低效率函数

> 如果你写了一段代码，它的执行效率比想象中的要差很多。我们需要知道有哪些因素有可能影响到这段代码的执行效率。例如：比较两个float数值大小的执行时间是int数值的4倍左右。这是因为CPU的运算架构导致的，如下图所示：

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image1.png)

> 虽然现代的CPU架构得到了很大的提升，也许并不存在上面所示的那么大的差异，但是这个例子说明了代码写法上的差异会对运算性能产生很大的影响。
>
> 通常来说有两类运行效率差的情况：第1种是相对执行时间长的方法，我们可以很轻松的找到这些方法并做一定的优化。第2种是执行时间短，但是执行频次很高的方法，因为执行次数多，累积效应下就会对性能产生很大的影响。
>
> 修复这些细节效率问题，需要使用Android SDK提供的工具，进行仔细的测量，然后再进行微调修复。
>
> 工具  android profiler 的**Traceview**

#### (2)优化

>##### (1).批量处理与缓存
>
>为了提升运算性能，这里介绍2个非常重要的技术:批处理与缓存
> 是在真正执行运算操作之前对数据进行批量预处理，例如你需要有这样一个方法，它的作用是查找某个值是否存在与于一堆数据中。假设一个前提，我们会先对数据做排序，然后使用二分查找法来判断值是否存在。我们先看第一种情况，下图中存在着多次重复的排序操作。

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image2.png)

>在上面的那种写法下，如果数据的量级并不大的话，应该还可以接受，可是如果数据集非常大，就会有严重的效率问题。那么我们看下改进的写法，把排序的操作打包绑定只执行一次

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image3.png)

>上面就是批处理的一种示例：把重复的操作拎出来，打包只执行一次。
> 缓存相对比较简单，就是把经常处理的数据先缓存起来，使用时直接获取，但是要注意，当代码执行完毕需要回收（当然也可以使用weakRefrence）。
>
>###### (2).主线程阻塞
>
>为了确保应用程序的高性能，每项功能都应该尽可能高效地运行。但是这些功能的执行时间以及它们在代码中所处的位置也很重要，当你首次启动一个Android应用程序时，朱执行线程就已经创建了，主线程非常重要，因为它负责运行你的代码，并在合适的视图位置发送事件和执行绘图功能。这些前面我们已经讲过，基本上来说，主线程是应用程序所在的线程，有时候，主线程也称为UI线程。例如，如果你触摸屏幕上的按钮，UI线程将会发送一个触摸事件给视图，视图将按钮状态设定为已按下设定，然后向事件队列发送一个有效请求，然后UI线程处理此请求，并通知按钮将其本身绘制为已按下状态。如果你有任何触摸事件的处理代码块，将会在线程中执行，这些触摸处理所用的时间越长，线程的执行时间就会越长，在绘图功能执行完之前，视图将会更新显示状态，让用户能够看到其状态，这里需要记住的是，输入处理代码与渲染和更新代码，共享这个线程的处理周期时间。

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image4.png)

>这意味着，在触摸事件处理，网络访问或数据库查询等计算周期时间，UI不会更新绘图，在简单的情况下，渲染周期可能会延误16毫秒左右，而让用户感到延迟。但是，如果你暂停UI线程渲染超过5秒，用户将会看到“应用程序未响应”对话框，并询问用户是否会想要关闭你的应用程序，这样可能导致用户停止使用。那你如何解决这个问题，你要找出不需要在主线程上执行的功能，也就是说，不需要等它们完成之后，才能执行绘图。你应该将这个功能转移到一个单独的独立线程，这个线程不会阻止UI线程。例如，如果你按一下提交按钮，以完成一个订单，然后编写和发送确认邮件，

![](这可以在单独的线程上完成。Android有系列很好用的API，能够简化这些工作。

> ###### (3).异步任务
>
> 给耗时操作建立异步任务，比如网络请求，图片处理等等，任务完成通知主线程。
>
> ###### (4).容器性能
>
> 前面我们讲过，一些类型的硬件可能会造成程序执行速度较慢，还记得那个浮点分支问题吗？对于今天的硬件来说，这已经不是问题。但是有一些问题还是需要引起注意，比如说，你所使用的编程语言的基本元素的效率，以排序等基本算法为例，现在，有很多的排序算法，对于不同的情况，它们各有优劣，例如，当元素数量少于一千或在大型已排序列表中寻找一个对象时，快速排序法通常比起冒泡排序法更快。一般情况下，最好的方法是二分查找算法，但是，当在未排数组中寻找对象时情况变得完全不同，不同于比较每一个对象以查找你想要的值。你可以使用一个哈希函数来立即找到它，这是现代计算机科学和数据结构方面的基本知识。

> 幸运的是，现代编程语言像Java等，为你提供了这些容器和算法，因此你不再需要自己反复地编写Murmur3哈希函数和快速排序算法。但是你需要知道另外一些事情，在我多年的编程生涯中，一个经常会影响项目性能的问题，是由于这些语言提供的容器对象的性能所引起的。这听起来不可思议！Java提供一个矢量类的实现，你可以任意push、pop，添加和取消对象，为了获得这种灵活性，它在内部使用链式列表结构，这种结构具有一系列独特的性能特性，在你操作这种列表时，它的速度超级快，但是，当你在其他位置进行插入或删除时，它会消耗大量的时间。我要说的是，底层系统提供的这些容器并不会考虑，你的程序将会如何实际使用它们，James Sutherland发表了一系列的基准测试报告，他认为，我们需要注意性能与功能之间的一些差异。例如，他发现Hashtable比HashMap大约快22%，具体视你如何使用这些容器而有所不同，我们需要思考的是，你是否曾经分析过你在代码中使用的容器类。你是否坚信，你在代码中使用的容器的实际运行速度绝对是最快的。一个好消息是，你可以使用Android中的MPI来剖析这些容器的性能。

![](/Users/candice/Documents/笔记/Android/内存优化/计算性能-image6.png)

>###### (5).数据结构
>
>创建应用时，容器中不恰当的数据结构所造成的性能问题，为此我们可以使用Android SDK中的工具，来识别不恰当数据结构带来的性能问题。

### 3.电量优化

​	当我们使用Android完成任务时，设备硬件正在快速消耗电池电量来完成这些任务。任务越繁重，消耗的电量越多越快。这样用户就会在想是哪一个应用导致电量消耗的怎么快的？要想写出耗电量低的应用的关键是要透彻理解电量消耗的全部过程。 我们很想知道我的应用执行的哪些任务消耗的电量是最多的？这个问题确实会很棘手。电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗（因为第三方硬件监测的时候是用的自己的供电而不是用的手机的电量）。

#### (1)电量消耗分析

>待机状态的电量分析
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image1.png)

>使用和唤醒屏幕后
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image2.png)

>当设备从休眠状态中，被应用程序假面唤醒时，你会看到在第一次唤醒时，这里有一条电量使用高峰线
>
>CUP唤醒时的高峰线
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image3.png)

>后续的一些执行的消耗
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image4.png)

>值得注意的是当工作完成后，设备会主动进行休眠，这非常重要，在不使用或者很少使用的情况下，长时间保持屏幕唤醒会迅速消耗电池的电量。
>
>**蜂窝式无线**
> 当设备通过无线网发送数据的时候，为了使用硬件，这里会出现一个唤醒好点高峰。接下来还有一个高数值，这是发送数据包消耗的电量，然后接受数据包也会消耗大量电量 也看到一个峰值。
> 所以我们知道了，开启无线模式这个过程非常耗电，那么硬件这块为了防止频繁开启关闭耗电，采取了一个无奈的办法，会在一个小段时间内保持开启模式，防止短时间内还有数据包需要接收。这些数据非常有用，可是 不是所有开发者都有这个第三方设备跟踪。但是使用Android L版本就可以利用到新的一系列的工具来优化应用程序的耗电。（这里显然不要考虑兼容性问题吧，我只是想测电量消耗问题，同一款APP在不同版本上耗电情况应该不会有太大影响。）

#### (2) Battery Historian(电量使用记录分析工具)

>Battery Historian是Android 5.0开始引入的新API。通过下面的指令，可以得到设备上的电量消耗信息:
>
>###### 2.1 配置分析环境
>
>第一种 通过安装Docker环境来安装
> 因本人没有使用这种，想要了解的朋友可以参考文档
> 第二种 源码安装
>
>###### (1).GO环境安装[下载](https://golang.org/doc/install?download=go1.7.3.windows-amd64.msi) 
>
>###### (2). 安装Git[下载](https://git-scm.com/) 
>
>###### (3). 安装Python[下载](https://www.python.org/) 
>
>###### (4). 安装Java环境
>
>###### (5). 下载Battery Historian源码并且运行
>
>**下载源码**
>
>```
> go get -d -u github.com/google/battery-historian/
>```
>
>**运行Battery Historian**
>
>```
>cd $GOPATH/src/github.com/google/battery-historian
>    go run setup.go
>```

>**开启服务**
>
>```
>   go run cmd/battery-historian/battery-historian.go
>```
>
>**检查/battery-historian是否运行**
>
>```
>检查/battery-historian是否运行
>```
>
>###### 2.2 导出电量发现文件
>
>historian-V1
>
>```
>$ adb shell dumpsys batterystats > xxx.txt  //得到整个设备的电量消耗信息
>    $ adb shell dumpsys batterystats > com.package.name > xxx.txt //得到指定app相关的电量消耗信息
>```
>
>historian-V2
>android 6.0 以及以下版本
>
>```
>  adb bugreport > bugreport.txt
>```
>
>android 7.0
>
>```
>adb bugreport bugreport.zip
>```
>
>###### 2.3 开始分析
>
>启动battery-historian服务，打开[http://localhost:9999](http://localhost:9999/)，上传bugreport.txt或者bugreport.zip文件
>
>待补充

https://www.jianshu.com/p/6affacabad5b

#### (3) 如何保持设备唤醒状态

>当Android设备空闲时,屏幕会变暗，然后关闭屏幕，最后会停止CPU的运行，这样可以防止电池电量掉的快。在休眠过程中自定义的Timer、Handler、Thread、Service等都会暂停。
>
>###### 什么情况下需要唤醒设备？
>
>对于一些带通讯功能的应用，通讯的心跳包会在熄屏不久后停止网络访问，所以需要定时唤醒cpu。
> 后台关键逻辑代码执行时，防止cpu休眠
> 后台长连接的状态
> 后台定时任务执行
>
>常用唤醒设备的方法
>
>##### (1).保持屏幕常亮
>
>- activity中设置
>
>```java
>//保持屏幕常亮
> getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
> //取消屏幕常亮
> getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
>```
>
>- 配置文件中设置
>
>```java
><RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
>        xmlns:tools="http://schemas.android.com/tools"
>        android:id="@+id/activity_screen_on"
>        android:layout_width="match_parent"
>        android:layout_height="match_parent"
>        android:keepScreenOn="true">
>```
>
>这个方法的好处是不像唤醒锁（wake locks），需要一些特定的权限（permission）。并且能正确管理不同app之间的切换，不用担心无用资源的释放问题。
>
>##### (2).保持CPU运行(wake locks)
>
>wake_lock锁主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。
> 需要使用PowerManager这个系统服务的唤醒锁(wake locks)特征来保持CPU处于唤醒状态。唤醒锁允许程序控制宿主设备的电量状态。创建和持有唤醒锁对电池的续航有较大的影响，所以，除非是真的需要唤醒锁完成尽可能短的时间在后台完成的任务时才使用它。
>
>###### 使用场景
>
>在使用后台服务在屏幕关闭情况下hold住CPU完成一些工作。
>
>###### 不使用wake locks,执行长时间任务可能导致的问题？
>
>如果不使用唤醒锁来执行后台服务，不能保证因CPU休眠未来的某个时刻任务会停止
>
>###### 唤醒锁可划分为并识别四种用户唤醒锁：
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image5.png)

>**注意： android sdk 大于17 后，FULL_WAKE_LOCK 将被弃用。 应用应使用 FLAG_KEEP_SCREEN_ON。**
>
>###### wake locks 使用步骤
>
>- ###### 添加唤醒锁权限
>
>```java
><uses-permission android:name="android.permission.WAKE_LOCK" />
>```
>
>- 使用
>
>```java
>PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);
>PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "myPartialWakeLock");
>//唤醒
>wakeLock.acquire();
>//执行任务
>doJob();
>//释放锁
>if (wakeLock.isHeld()) {
>   wakeLock.release();
>}
>```
>

>**注意：在使用该类的时候，必须保证acquire和release是成对出现的。**
>
>我们也可以使用带超时的acquire,防止没有手动释放
>
>**WakefulBroadcastReceiver**
>
>官方推荐使用WakefulBroadcastReceiver。下面来看下定义和使用。
> WakefulBroadcastReceiver是BroadcastReceiver的一种特例。它会为你的APP创建和管理一个PARTIAL_WAKE_LOCK 类型的WakeLock。WakefulBroadcastReceiver把工作交接给service（通常是IntentService），并保证交接过程中设备不会进入休眠状态。如果不持有WakeLock，设备很容易在任务未执行完前休眠。最终结果是你的应用不知道会在什么时候能把工作完成，相信这不是你想要的。
>
>**使用**
>
>- 注册
>
>- ```java
>	 <receiver android:name=".battery.MyWakefulReceiver"></receiver>
>	```
>
>- 使用
>
>- ```java
>	public class MyWakefulReceiver extends WakefulBroadcastReceiver {       
>	        @Override
>	        public void onReceive(Context context, Intent intent) {
>	            Intent mIntent = new Intent(context,MyService.class);
>	            startWakefulService(context,mIntent);
>	        }
>	    }
>	    public class MyService extends IntentService {
>	        /**
>	         * Creates an IntentService.  Invoked by your subclass's constructor.
>	         *
>	         * @param name Used to name the worker thread, important only for debugging.
>	         */
>	        public MyService(String name) {
>	            super(name);
>	        }
>	
>	        @Override
>	        protected void onHandleIntent(Intent intent) {
>	            Bundle extras = intent.getExtras();
>	            //执行任务
>	            doJob();        
>	            MyWakefulReceiver.completeWakefulIntent(intent);
>	        }
>	```
>
>**AlarmManager 唤醒CPU**
>
>###### **为什么AM能在cpu休眠时，唤醒它呢？**
>
>首先Android手机有两个处理器，一个叫Application Processor（AP），一个叫Baseband Processor（BP）。AP是ARM架构的处理器，用于运行Linux+Android系统；BP用于运行实时操作系统（RTOS），通讯协议栈运行于BP的RTOS之上。非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高。另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。一般手机待机时，AP、LCD、WIFI均进入休眠状态，这时Android中应用程序的代码也会停止执行。
>
>Android为了确保应用程序中关键代码的正确执行，提供了Wake Lock的API，使得应用程序有权限通过代码阻止AP进入休眠状态。但如果不领会Android设计者的意图而滥用Wake Lock API，为了自身程序在后台的正常工作而长时间阻止AP进入休眠状态，就会成为待机电池杀手。
>
>AlarmManager 是Android 系统封装的用于管理 RTC 的模块，RTC (Real Time Clock) 是一个独立的硬件时钟，可以在 CPU 休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。
>
>**使用：**
>
>```java
>    public void btn_alarm(View view){
>        Intent mIntent = new Intent(view.getContext(),TestService.class);
>        PendingIntent pendingIntent = PendingIntent.getService(view.getContext(),mRequestCode,mIntent,mFlags);
>        AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);
>        if(alarmManager != null){
>            long mTriggerTime = System.currentTimeMillis() + 1000;
>            long mItervalTime = 2000;
>            alarmManager.cancel(pendingIntent);
>            //闹钟在系统睡眠状态下会唤醒系统并执行提示功能
>            alarmManager.setRepeating(AlarmManager.RTC_WAKEUP,mTriggerTime,mItervalTime,pendingIntent);
>//            alarmManager.setExact(AlarmManager.RTC_WAKEUP,mTriggerTime,pendingIntent);
>//            alarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pendingIntent);
>        }
>    }
>```
>
>该定时器可以启动Service服务、发送广播、跳转Activity，并且会在系统睡眠状态下唤醒系统。所以该方法不用获取电源锁和释放电源锁。
>
>**注意：在19以上版本，setRepeating中设置的频繁只是建议值(6.0 的源码中最小值是60s)，如果要精确一些的用setWindow或者setExact。**
>
>**注意：由于手机厂商做了心跳对齐，所有的app后台唤醒频率不能太高，不然会无效。**
>
>**总结:**
>
>- 关键逻辑的执行过程，就需要Wake Lock来保护。如断线重连重新登陆
>
>- 2.休眠的情况下如何唤醒来执行任务？用AlarmManager。如推送消息的获取
>
>###### 注意：如果请求网络很差，会要很长的时间，一般我们谷歌建议一定要设置请求超时时间。

#### (4) 电量优化建议

>##### 4.1**充电时执行任务**
>
>为了省电，有些工作可以放当手机插上电源的时候去做。往往这样的情况非常多。像这些不需要及时地和用户交互的操作可以放到后面处理。
>
>```java
>if (!checkForPower()) {
>        Toast.makeText(view.getContext(), "当前非充电状态", Toast.LENGTH_SHORT).show();
>        return;
>    }
>    /**
>         * 是否充电
>         * AC --- 交流电
>         * USB
>         * WireLess -- 无线充电
>         *
>         * @return
>         */
>        private boolean checkForPower() {
>            IntentFilter mIntentFilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
>            Intent intent = registerReceiver(null, mIntentFilter);
>            int plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
>
>            boolean isUsb = plugged == BatteryManager.BATTERY_PLUGGED_USB;
>            boolean isAc = plugged == BatteryManager.BATTERY_PLUGGED_AC;
>            boolean isWireless = false;
>            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
>                //api >= 17
>                isWireless = plugged == BatteryManager.BATTERY_PLUGGED_WIRELESS;
>            }
>            return (isUsb || isAc || isWireless);
>        }
>
>
>```
>
>##### 4.2 **连接Wifi后执行任务**
>
>我们知道wifi网络传输的电量消耗要比移动网络少很多，应该尽量减少移动网络下的数据传输，多在WiFi环境下传输数据，所以我们可以把一些不需要实时性的任务留到连接wifi后在执行
>
>##### 4.3 **wake_lock**
>
>系统为了节省电量，CPU在没有任务忙的时候就会自动进入休眠。
> 有任务需要唤醒CPU高效执行的时候，就会给CPU加wake_lock锁。
> 但是根据我们上面的讲解，使用wake_lock结束时需要释放锁，如果忘记释放，会使得CPU一直执行消耗电量，所以推荐使用带超时的wake lock或者WakefulBroadcastReceiver
>
>```java
>   wakeLock.acquire(timeout);
>```

>##### 4.4 **大量高频次的CPU唤醒及操作集中处理**
>
>我们希望把频繁的间隔任务集中起来进行批量执行， 这正是JobScheduler API所做的事情。它会根据当前的情况与任务，组合出理想的唤醒时间，例如等到正在充电或者连接到WiFi的时候，或者集中任务一起执行。我们可以通过这个API实现很多免费的调度算法。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image6.png)

>![](/Users/candice/Documents/笔记/Android/内存优化/电量优化-image7.png)
>
>###### JobScheduler
>
>使用Job Scheduler，应用需要做的事情就是判断哪些任务是不紧急的，可以交给Job Scheduler来处理，Job Scheduler集中处理收到的任务，选择合适的时间，合适的网络，再一起进行执行。使用(android api >= 21)
>
>```java
>@TargetApi(Build.VERSION_CODES.LOLLIPOP)
>    public class JobWakeUpService extends JobService{
>        private int mJobID = 100;
>        private JobScheduler mJobScheduler;
>        private long mIntervalMillis = 6000;
>        private long mMinLatencyMillis = 5000;
>        private long mMaxExecutionDelayMillis = 10000;
>
>        @Override
>        public int onStartCommand(Intent intent, int flags, int startId) {
>            JobInfo mJobInfo = new JobInfo.Builder(mJobID,new ComponentName(this,JobWakeUpService.class))
>                    .setPeriodic(mIntervalMillis)//设备重启，任务是否保留
>                    .setMinimumLatency(mMinLatencyMillis)//最小延时
>                    .setOverrideDeadline    (mMaxExecutionDelayMillis)//最大执行时间
>                    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)//网络类型 NETWORK_TYPE_UNMETERED（wifi 蓝牙）
>                    .setRequiresCharging(true) //充电时执行
>                    //设置重试/退避策略 （重试时间，重试时间间隔）
>                    .setBackoffCriteria(mInitialBackoffMillis,JobInfo.BACKOFF_POLICY_LINEAR)
>                    .build();
>
>            mJobScheduler = (JobScheduler) getSystemService(JOB_SCHEDULER_SERVICE);
>            mJobScheduler.schedule(mJobInfo);
>            return START_STICKY;
>        }
>
>        @Override
>        public boolean onStartJob(JobParameters params) {
>            if(!isServiceWork(this,TestService.class.getName())){
>                startService(new Intent(this,TestService.class));
>            }
>            return false;
>        }
>        @Override
>        public boolean onStopJob(JobParameters params) {
>            mJobScheduler.cancel(mJobID);
>    //        mJobScheduler.cancelAll();
>            return false;
>        }
>
>        /**
>         * 查询服务是否开启
>         * @param context
>         * @param serviceName
>         * @return
>         */
>        private boolean isServiceWork(Context context, String serviceName){
>            ActivityManager am= (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
>            List<ActivityManager.RunningServiceInfo> runningServices = am.getRunningServices(100);
>            if(runningServices == null){
>                return false;
>            }
>            for (ActivityManager.RunningServiceInfo service : runningServices) {
>                String className = service.service.getClassName();
>                if(className.equals(serviceName)){
>                    return true;
>                }
>            }
>            return false;
>        }
>```
>
>##### 4.5 定位
>
>定位完成，及时关闭
>如果需要实时定位，减少更新频率
>根据实际情况，选择gsp定位还是网络定位，降低电量消耗
>
>##### 4.6 **网络优化**
>
>手机的通过内置的射频模块和基站几乎, 从而链接上网的, 而这个射频模块(radio)是非常耗电的.
> 为了控制这个射频模块的耗电, 硬件驱动及Android RIL层做了很多处理. 例如可以单独关闭radio(飞行模式), 间歇性假休眠radio(有数据发生时才上电, 保持一个频率的与基站交互)等等.

### 4.网络优化

#### (1) 为什么要网络优化

>1.流量，虽然现在的wifi已经很普及，但还是有需要使用2G/3G/4G的的情况，那么流量是我们必须考虑的一部分（流量不便宜呀）
> 2.电量(重点)，电量是我们需要认真考虑的一方面，手机的续航能力是现在用户关注的一个点，如果手机电量消耗过快，用户可能会卸载那些消耗电量过大的应用。
> 3.响应时间(重点)，用户的体验是我们应用第一个目标，只有给用户好的体验，才能防止用户的流失。
> 4.安全（重点），网络数据传输的安全，是我们必须面对的一个问题，保护用户信息和数据的安全是我们的职责。

#### (2) 分析工具

>##### 2.1 **Network Monitor 介绍**
>
>Network Monitor 是Android Studio内置的网络监控工具。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/网络优化-image2.png)

>Rx --- Recive 表示下行流量
>
>Tx --- Transmit 表示上行流量
>
>##### 2.2 代理工具
>
>1.截获网络请求响应包, 分析网络请求
>2.设置代理网络
>
>Charles
>
>##### 2.3 模拟弱网

#### (3) 网络优化方案

>我们从任务的集中处理，传输数据优化，安全几个方面来讲解，最后在给出弱网情况下的一些建议
>
>###### 3.1 任务集中处理，节省流量,降低电量消耗
>
>这段内容在电量优化中已经讲过，这里不再重复太多，就对JobScheduler的使用在扩展下：
>
>```java
>JobInfo mJobInfo = new JobInfo.Builder(mJobID, new ComponentName(this, JobWakeUpService.class))
>            .setPeriodic(mIntervalMillis)//执行周期
>            .setMinimumLatency(mMinLatencyMillis)//最小延时
>            .setOverrideDeadline(mMaxExecutionDelayMillis)//最大执行时间
>            .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)//网络类型 NETWORK_TYPE_UNMETERED（wifi 蓝牙）
>            .setRequiresCharging(true) //充电时执行
>            //设置重试/退避策略 （重试时间，重试时间间隔）
>            .setBackoffCriteria(mInitialBackoffMillis, JobInfo.BACKOFF_POLICY_LINEAR)
>            .setPersisted(isPersisted)//设备重启，任务是否保留
>            .setRequiresDeviceIdle(isDeviceIdle)//设备空闲时
>            //监听url对应数据变化，触发当前任务执行
>            .addTriggerContentUri(mUrl)
>            //数据变化------->任务执行 最大延迟
>             .setTriggerContentMaxDelay(mDelay)
>            //更新 延迟
>           .setTriggerContentUpdateDelay(mUpdateDelay)
>            .build();
>```
>
>###### 3.2 传输数据优化，节省流量，响应更快
>
>- ###### gzip压缩
>
>	gzip 压缩 还是很常见的，在主流的网络访问框架中都有对应的api让你调用，我们以OKHttp为例：
>	gzip压缩拦截器：
>
>	```java
>	static class GzipRequestInterceptor implements Interceptor {
>	            @Override
>	            public Response intercept(Chain chain) throws IOException {
>	                okhttp3.Request originalRequest = chain.request();
>	                if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
>	                    return chain.proceed(originalRequest);
>	                }
>	
>	                okhttp3.Request compressedRequest = originalRequest.newBuilder()
>	                        .header("Content-Encoding", "gzip")
>	                        .method(originalRequest.method(), gzip(originalRequest.body()))
>	                        .build();
>	                return chain.proceed(compressedRequest);
>	            }
>	
>	            private RequestBody gzip(final okhttp3.RequestBody body) {
>	                return new RequestBody() {
>	                    @Override
>	                    public MediaType contentType() {
>	                        return body.contentType();
>	                    }
>	
>	                    @Override
>	                    public long contentLength() {
>	                        return -1; // 无法知道压缩后的数据大小
>	                    }
>	
>	                    @Override
>	                    public void writeTo(BufferedSink sink) throws IOException {
>	                        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
>	                        body.writeTo(gzipSink);
>	                        gzipSink.close();
>	                    }
>	                };
>	            }
>	        }
>	```
>
>- **代替JSON**
>
>	 使用Protocal Buffers，Nano-Proto-Buffers，FlatBuffer来减小序列化的数据的大小
>	Protocal Buffers,Nano-Proto-Buffers,FlatBuffers等相关知识可以在关于数据传输优化一章阅读，这里不再展开。
>
>- **缓存**
>
>	三级缓存还是很常用的，disk cache，mem cache,http cache,下面我们来分别聊一聊：
>
>	**http cache**
>
>	http协议自带的缓存策略，当资源没有修改时，http status 为304，可以看下下面的图：
>
>	![](/Users/candice/Documents/笔记/Android/内存优化/网络优化-image3.png)
>
>	ETag  请求变量的实体标签的当前值
>	 Last-Modified  请求资源的最后修改时间
>	 If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码
>	 If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变
>	 下面我们来看下Volley关于httpcache的使用：
>
>	```java
>	/**
>	 * 添加头---用于http缓存使用
>	 * @param headers
>	 * @param entry
>	 */
>	private void addCacheHeaders(Map<String, String> headers, Cache.Entry entry) {
>	    // If there's no cache entry, we're done.
>	    if (entry == null) {
>	        return;
>	    }
>	
>	    if (entry.etag != null) {
>	        headers.put("If-None-Match", entry.etag);
>	    }
>	
>	    if (entry.lastModified > 0) {
>	        Date refTime = new Date(entry.lastModified);
>	        headers.put("If-Modified-Since", DateUtils.formatDate(refTime));
>	    }
>	}
>	
>	```
>
>​      **memory cache**
>
>​	对于请求的是字符串或者json等文本的格式，是不需要内存缓存的。只有请求的是图片时才需要内存缓存对图片进行管理。对图片的管理使用LRU算法来进行管理。
>
>​     **disk cache**
>
>​     disk 缓存的实现大多数开源框架都是使用的jackwharton的杰作DiskLruCache
>
>- **图片压缩**

>##### 3.3 **不同的网络状况，做不同的事**
>
>​	在WiFi，4G，3G等不同的网络下设计不同大小的预取数据量，也可以是按照图片数量或者操作时间来作为阀值,我们还需要把当前的网络环境情况添加到设计预取数据量的策略当中去。判断当前设备的状态与网络情况,可以使用JobScheduler.
> 我们可以把网络请求延迟划分为三档：例如把网络延迟小于60ms的划分为GOOD，大于220ms的划分为BAD，介于两者之间的划分为OK（这里的60ms，220ms会需要根据不同的场景提前进行预算推测）。如果网络延迟属于GOOD的范畴，我们就可以做更多比较激进的预取数据的操作，如果网络延迟属于BAD的范畴，我们就应该考虑把当下的网络请求操作Hold住等待网络状况恢复到GOOD的状态再进行处理。
>
>![](/Users/candice/Documents/笔记/Android/内存优化/网络优化-image4.png)

>![](/Users/candice/Documents/笔记/Android/内存优化/网络优化-image5.png)
>
>提示：使用AT&T提供的AT&T Network Attenuator来帮助预估网络延迟
>
>##### 3.4 **安全，保护用户信息**
>
>###### 主要针对两个问题：
>
>1.保证API的调用者是经过自己授权的App
> 2.保证数据传输的安全。
> 第一个问题：我主要采用设计签名的方式。对每个客户端，Android、iOS、WeChat，分别分配一个AppKey和AppSecret。需要调用API时，将AppKey加入请求参数列表，并将AppSecret和所有参数一起，根据某种签名算法生成一个签名字符串，然后调用API时把该签名字符串也一起带上。服务端收到请求之后，根据请求中的AppKey查询相应的AppSecret，按照同样的签名算法，也生成一个签名字符串，当服务端生成的签名和请求带过来的签名一致的时候，那就表示这个请求的调用者是经过自己授权的，证明这个请求是安全的。而且，每个端都有一个Key，也方便不同端的标识和统计。为了防止AppSecret被别人获取，这个AppSecret一般写死在代码里面。另外，签名算法也需要有一定的复杂度，不能轻易被别人破解，最好是采用自己规定的一套签名算法，而不是采用外部公开的签名算法。另外，在参数列表中再加入一个时间戳，还可以防止部分重放攻击。
> 第二个问题：主要就是采用HTTPS了。HTTPS因为添加了SSL安全协议，自动对请求数据进行了压缩加密，在一定程序可以防止监听、防止劫持、防止重发，主要就是防止中间人攻击。苹果从iOS9开始，默认就采用HTTPS了。而关于在Android中如何使用HTTPS，Google官方也给出了很多安全建议。不过，大部分App并没有按照安全建议去实现，主要就是没有对SSL证书进行安全性检查，这就成为了一个很大的漏洞，中间人利用此漏洞用假证书就可以通过检查，从而可以劫持到所有数据了。因此，为了安全考虑，建议对SSL证书进行强校验，包括签名CA是否合法、域名是否匹配、是不是自签名证书、证书是否过期等。
>
>##### 3.5 **弱网情况下我们应该做些什么？**
>
>1).压缩/减少数据传输量
>(2).利用缓存减少网络传输
>(3).针对弱网(移动网络), 不自动加载图片
>(4).界面先反馈, 请求延迟提交